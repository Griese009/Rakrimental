{"mappings":"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","sources":["<anon>","src/ts/main.ts","src/ts/saving.ts","node_modules/localforage/dist/localforage.js","src/ts/layers/start.ts","src/ts/layers/layer.ts","src/ts/utils.ts","src/ts/layers/dice.ts","src/ts/layers/coin.ts"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    var $26ce26772c045640$exports = {};\n/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/ (function(f) {\n    var g;\n    $26ce26772c045640$exports = f();\n})(function() {\n    var define, module1, exports;\n    return (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = undefined;\n                    if (!u && a) return a(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f;\n                }\n                var l = n[o] = {\n                    exports: {}\n                };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }\n            return n[o].exports;\n        }\n        var i = undefined;\n        for(var o = 0; o < r.length; o++)s(r[o]);\n        return s;\n    })({\n        1: [\n            function(_dereq_, module1, exports) {\n                (function(global1) {\n                    \"use strict\";\n                    var Mutation = global1.MutationObserver || global1.WebKitMutationObserver;\n                    var scheduleDrain;\n                    if (Mutation) {\n                        var called = 0;\n                        var observer = new Mutation(nextTick);\n                        var element = global1.document.createTextNode(\"\");\n                        observer.observe(element, {\n                            characterData: true\n                        });\n                        scheduleDrain = function() {\n                            element.data = called = ++called % 2;\n                        };\n                    } else if (!global1.setImmediate && typeof global1.MessageChannel !== \"undefined\") {\n                        var channel = new global1.MessageChannel();\n                        channel.port1.onmessage = nextTick;\n                        scheduleDrain = function() {\n                            channel.port2.postMessage(0);\n                        };\n                    } else if (\"document\" in global1 && \"onreadystatechange\" in global1.document.createElement(\"script\")) scheduleDrain = function() {\n                        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n                        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n                        var scriptEl = global1.document.createElement(\"script\");\n                        scriptEl.onreadystatechange = function() {\n                            nextTick();\n                            scriptEl.onreadystatechange = null;\n                            scriptEl.parentNode.removeChild(scriptEl);\n                            scriptEl = null;\n                        };\n                        global1.document.documentElement.appendChild(scriptEl);\n                    };\n                    else scheduleDrain = function() {\n                        setTimeout(nextTick, 0);\n                    };\n                    var draining;\n                    var queue = [];\n                    //named nextTick for less confusing stack traces\n                    function nextTick() {\n                        draining = true;\n                        var i, oldQueue;\n                        var len = queue.length;\n                        while(len){\n                            oldQueue = queue;\n                            queue = [];\n                            i = -1;\n                            while(++i < len)oldQueue[i]();\n                            len = queue.length;\n                        }\n                        draining = false;\n                    }\n                    module1.exports = immediate;\n                    function immediate(task) {\n                        if (queue.push(task) === 1 && !draining) scheduleDrain();\n                    }\n                }).call(this, typeof $parcel$global !== \"undefined\" ? $parcel$global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n            },\n            {}\n        ],\n        2: [\n            function(_dereq_, module1, exports) {\n                \"use strict\";\n                var immediate = _dereq_(1);\n                /* istanbul ignore next */ function INTERNAL() {}\n                var handlers = {};\n                var REJECTED = [\n                    \"REJECTED\"\n                ];\n                var FULFILLED = [\n                    \"FULFILLED\"\n                ];\n                var PENDING = [\n                    \"PENDING\"\n                ];\n                module1.exports = Promise1;\n                function Promise1(resolver) {\n                    if (typeof resolver !== \"function\") throw new TypeError(\"resolver must be a function\");\n                    this.state = PENDING;\n                    this.queue = [];\n                    this.outcome = void 0;\n                    if (resolver !== INTERNAL) safelyResolveThenable(this, resolver);\n                }\n                Promise1.prototype[\"catch\"] = function(onRejected) {\n                    return this.then(null, onRejected);\n                };\n                Promise1.prototype.then = function(onFulfilled, onRejected) {\n                    if (typeof onFulfilled !== \"function\" && this.state === FULFILLED || typeof onRejected !== \"function\" && this.state === REJECTED) return this;\n                    var promise = new this.constructor(INTERNAL);\n                    if (this.state !== PENDING) {\n                        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n                        unwrap(promise, resolver, this.outcome);\n                    } else this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n                    return promise;\n                };\n                function QueueItem(promise, onFulfilled, onRejected) {\n                    this.promise = promise;\n                    if (typeof onFulfilled === \"function\") {\n                        this.onFulfilled = onFulfilled;\n                        this.callFulfilled = this.otherCallFulfilled;\n                    }\n                    if (typeof onRejected === \"function\") {\n                        this.onRejected = onRejected;\n                        this.callRejected = this.otherCallRejected;\n                    }\n                }\n                QueueItem.prototype.callFulfilled = function(value) {\n                    handlers.resolve(this.promise, value);\n                };\n                QueueItem.prototype.otherCallFulfilled = function(value) {\n                    unwrap(this.promise, this.onFulfilled, value);\n                };\n                QueueItem.prototype.callRejected = function(value) {\n                    handlers.reject(this.promise, value);\n                };\n                QueueItem.prototype.otherCallRejected = function(value) {\n                    unwrap(this.promise, this.onRejected, value);\n                };\n                function unwrap(promise, func, value) {\n                    immediate(function() {\n                        var returnValue;\n                        try {\n                            returnValue = func(value);\n                        } catch (e) {\n                            return handlers.reject(promise, e);\n                        }\n                        if (returnValue === promise) handlers.reject(promise, new TypeError(\"Cannot resolve promise with itself\"));\n                        else handlers.resolve(promise, returnValue);\n                    });\n                }\n                handlers.resolve = function(self1, value) {\n                    var result = tryCatch(getThen, value);\n                    if (result.status === \"error\") return handlers.reject(self1, result.value);\n                    var thenable = result.value;\n                    if (thenable) safelyResolveThenable(self1, thenable);\n                    else {\n                        self1.state = FULFILLED;\n                        self1.outcome = value;\n                        var i = -1;\n                        var len = self1.queue.length;\n                        while(++i < len)self1.queue[i].callFulfilled(value);\n                    }\n                    return self1;\n                };\n                handlers.reject = function(self1, error) {\n                    self1.state = REJECTED;\n                    self1.outcome = error;\n                    var i = -1;\n                    var len = self1.queue.length;\n                    while(++i < len)self1.queue[i].callRejected(error);\n                    return self1;\n                };\n                function getThen(obj) {\n                    // Make sure we only access the accessor once as required by the spec\n                    var then = obj && obj.then;\n                    if (obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof then === \"function\") return function appyThen() {\n                        then.apply(obj, arguments);\n                    };\n                }\n                function safelyResolveThenable(self1, thenable) {\n                    // Either fulfill, reject or reject with error\n                    var called = false;\n                    function onError(value) {\n                        if (called) return;\n                        called = true;\n                        handlers.reject(self1, value);\n                    }\n                    function onSuccess(value) {\n                        if (called) return;\n                        called = true;\n                        handlers.resolve(self1, value);\n                    }\n                    function tryToUnwrap() {\n                        thenable(onSuccess, onError);\n                    }\n                    var result = tryCatch(tryToUnwrap);\n                    if (result.status === \"error\") onError(result.value);\n                }\n                function tryCatch(func, value) {\n                    var out = {};\n                    try {\n                        out.value = func(value);\n                        out.status = \"success\";\n                    } catch (e) {\n                        out.status = \"error\";\n                        out.value = e;\n                    }\n                    return out;\n                }\n                Promise1.resolve = resolve;\n                function resolve(value) {\n                    if (value instanceof this) return value;\n                    return handlers.resolve(new this(INTERNAL), value);\n                }\n                Promise1.reject = reject;\n                function reject(reason) {\n                    var promise = new this(INTERNAL);\n                    return handlers.reject(promise, reason);\n                }\n                Promise1.all = all;\n                function all(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") return this.reject(new TypeError(\"must be an array\"));\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) return this.resolve([]);\n                    var values = new Array(len);\n                    var resolved = 0;\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len)allResolver(iterable[i], i);\n                    return promise;\n                    function allResolver(value, i) {\n                        self1.resolve(value).then(resolveFromAll, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                        function resolveFromAll(outValue) {\n                            values[i] = outValue;\n                            if (++resolved === len && !called) {\n                                called = true;\n                                handlers.resolve(promise, values);\n                            }\n                        }\n                    }\n                }\n                Promise1.race = race;\n                function race(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") return this.reject(new TypeError(\"must be an array\"));\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) return this.resolve([]);\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len)resolver(iterable[i]);\n                    return promise;\n                    function resolver(value) {\n                        self1.resolve(value).then(function(response) {\n                            if (!called) {\n                                called = true;\n                                handlers.resolve(promise, response);\n                            }\n                        }, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                    }\n                }\n            },\n            {\n                \"1\": 1\n            }\n        ],\n        3: [\n            function(_dereq_, module1, exports) {\n                (function(global1) {\n                    \"use strict\";\n                    if (typeof global1.Promise !== \"function\") global1.Promise = _dereq_(2);\n                }).call(this, typeof $parcel$global !== \"undefined\" ? $parcel$global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n            },\n            {\n                \"2\": 2\n            }\n        ],\n        4: [\n            function(_dereq_, module1, exports) {\n                \"use strict\";\n                var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                };\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n                }\n                function getIDB() {\n                    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */ try {\n                        if (typeof indexedDB !== \"undefined\") return indexedDB;\n                        if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;\n                        if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;\n                        if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;\n                        if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;\n                    } catch (e) {\n                        return;\n                    }\n                }\n                var idb = getIDB();\n                function isIndexedDBValid() {\n                    try {\n                        // Initialize IndexedDB; fall back to vendor-prefixed versions\n                        // if needed.\n                        if (!idb || !idb.open) return false;\n                        // We mimic PouchDB here;\n                        //\n                        // We test for openDatabase because IE Mobile identifies itself\n                        // as Safari. Oh the lulz...\n                        var isSafari = typeof openDatabase !== \"undefined\" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n                        var hasFetch = typeof fetch === \"function\" && fetch.toString().indexOf(\"[native code\") !== -1;\n                        // Safari <10.1 does not meet our requirements for IDB support\n                        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n                        // Safari 10.1 shipped with fetch, we can use that to detect it.\n                        // Note: this creates issues with `window.fetch` polyfills and\n                        // overrides; see:\n                        // https://github.com/localForage/localForage/issues/856\n                        return (!isSafari || hasFetch) && typeof indexedDB !== \"undefined\" && // some outdated implementations of IDB that appear on Samsung\n                        // and HTC Android devices <4.4 are missing IDBKeyRange\n                        // See: https://github.com/mozilla/localForage/issues/128\n                        // See: https://github.com/mozilla/localForage/issues/272\n                        typeof IDBKeyRange !== \"undefined\";\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                function createBlob(parts, properties) {\n                    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */ parts = parts || [];\n                    properties = properties || {};\n                    try {\n                        return new Blob(parts, properties);\n                    } catch (e) {\n                        if (e.name !== \"TypeError\") throw e;\n                        var Builder = typeof BlobBuilder !== \"undefined\" ? BlobBuilder : typeof MSBlobBuilder !== \"undefined\" ? MSBlobBuilder : typeof MozBlobBuilder !== \"undefined\" ? MozBlobBuilder : WebKitBlobBuilder;\n                        var builder = new Builder();\n                        for(var i = 0; i < parts.length; i += 1)builder.append(parts[i]);\n                        return builder.getBlob(properties.type);\n                    }\n                }\n                // This is CommonJS because lie is an external dependency, so Rollup\n                // can just ignore it.\n                if (typeof Promise === \"undefined\") // In the \"nopromises\" build this will just throw if you don't have\n                // a global promise object, but it would throw anyway later.\n                _dereq_(3);\n                var Promise$1 = Promise;\n                function executeCallback(promise, callback) {\n                    if (callback) promise.then(function(result) {\n                        callback(null, result);\n                    }, function(error) {\n                        callback(error);\n                    });\n                }\n                function executeTwoCallbacks(promise, callback, errorCallback) {\n                    if (typeof callback === \"function\") promise.then(callback);\n                    if (typeof errorCallback === \"function\") promise[\"catch\"](errorCallback);\n                }\n                function normalizeKey(key) {\n                    // Cast the key to a string, as that's all we can set as a key.\n                    if (typeof key !== \"string\") {\n                        console.warn(key + \" used as a key, but it is not a string.\");\n                        key = String(key);\n                    }\n                    return key;\n                }\n                function getCallback() {\n                    if (arguments.length && typeof arguments[arguments.length - 1] === \"function\") return arguments[arguments.length - 1];\n                }\n                // Some code originally from async_storage.js in\n                // [Gaia](https://github.com/mozilla-b2g/gaia).\n                var DETECT_BLOB_SUPPORT_STORE = \"local-forage-detect-blob-support\";\n                var supportsBlobs = void 0;\n                var dbContexts = {};\n                var toString = Object.prototype.toString;\n                // Transaction Modes\n                var READ_ONLY = \"readonly\";\n                var READ_WRITE = \"readwrite\";\n                // Transform a binary string to an array buffer, because otherwise\n                // weird stuff happens when you try to work with the binary string directly.\n                // It is known.\n                // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n                // encode-decode-image-with-base64-breaks-image (2013-04-21)\n                function _binStringToArrayBuffer(bin) {\n                    var length = bin.length;\n                    var buf = new ArrayBuffer(length);\n                    var arr = new Uint8Array(buf);\n                    for(var i = 0; i < length; i++)arr[i] = bin.charCodeAt(i);\n                    return buf;\n                }\n                //\n                // Blobs are not supported in all versions of IndexedDB, notably\n                // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n                //\n                // Various other blob bugs exist in Chrome v37-42 (inclusive).\n                // Detecting them is expensive and confusing to users, and Chrome 37-42\n                // is at very low usage worldwide, so we do a hacky userAgent check instead.\n                //\n                // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n                // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n                // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n                //\n                // Code borrowed from PouchDB. See:\n                // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n                //\n                function _checkBlobSupportWithoutCaching(idb) {\n                    return new Promise$1(function(resolve) {\n                        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n                        var blob = createBlob([\n                            \"\"\n                        ]);\n                        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, \"key\");\n                        txn.onabort = function(e) {\n                            // If the transaction aborts now its due to not being able to\n                            // write to the database, likely due to the disk being full\n                            e.preventDefault();\n                            e.stopPropagation();\n                            resolve(false);\n                        };\n                        txn.oncomplete = function() {\n                            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n                            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n                            // MS Edge pretends to be Chrome 42:\n                            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n                        };\n                    })[\"catch\"](function() {\n                        return false; // error, so assume unsupported\n                    });\n                }\n                function _checkBlobSupport(idb) {\n                    if (typeof supportsBlobs === \"boolean\") return Promise$1.resolve(supportsBlobs);\n                    return _checkBlobSupportWithoutCaching(idb).then(function(value) {\n                        supportsBlobs = value;\n                        return supportsBlobs;\n                    });\n                }\n                function _deferReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Create a deferred object representing the current database operation.\n                    var deferredOperation = {};\n                    deferredOperation.promise = new Promise$1(function(resolve, reject) {\n                        deferredOperation.resolve = resolve;\n                        deferredOperation.reject = reject;\n                    });\n                    // Enqueue the deferred operation.\n                    dbContext.deferredOperations.push(deferredOperation);\n                    // Chain its promise to the database readiness.\n                    if (!dbContext.dbReady) dbContext.dbReady = deferredOperation.promise;\n                    else dbContext.dbReady = dbContext.dbReady.then(function() {\n                        return deferredOperation.promise;\n                    });\n                }\n                function _advanceReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Resolve its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.resolve();\n                        return deferredOperation.promise;\n                    }\n                }\n                function _rejectReadiness(dbInfo, err) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Reject its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.reject(err);\n                        return deferredOperation.promise;\n                    }\n                }\n                function _getConnection(dbInfo, upgradeNeeded) {\n                    return new Promise$1(function(resolve, reject) {\n                        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n                        if (dbInfo.db) {\n                            if (upgradeNeeded) {\n                                _deferReadiness(dbInfo);\n                                dbInfo.db.close();\n                            } else return resolve(dbInfo.db);\n                        }\n                        var dbArgs = [\n                            dbInfo.name\n                        ];\n                        if (upgradeNeeded) dbArgs.push(dbInfo.version);\n                        var openreq = idb.open.apply(idb, dbArgs);\n                        if (upgradeNeeded) openreq.onupgradeneeded = function(e) {\n                            var db = openreq.result;\n                            try {\n                                db.createObjectStore(dbInfo.storeName);\n                                if (e.oldVersion <= 1) // Added when support for blob shims was added\n                                db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                            } catch (ex) {\n                                if (ex.name === \"ConstraintError\") console.warn('The database \"' + dbInfo.name + '\"' + \" has been upgraded from version \" + e.oldVersion + \" to version \" + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                                else throw ex;\n                            }\n                        };\n                        openreq.onerror = function(e) {\n                            e.preventDefault();\n                            reject(openreq.error);\n                        };\n                        openreq.onsuccess = function() {\n                            var db = openreq.result;\n                            db.onversionchange = function(e) {\n                                // Triggered when the database is modified (e.g. adding an objectStore) or\n                                // deleted (even when initiated by other sessions in different tabs).\n                                // Closing the connection here prevents those operations from being blocked.\n                                // If the database is accessed again later by this instance, the connection\n                                // will be reopened or the database recreated as needed.\n                                e.target.close();\n                            };\n                            resolve(db);\n                            _advanceReadiness(dbInfo);\n                        };\n                    });\n                }\n                function _getOriginalConnection(dbInfo) {\n                    return _getConnection(dbInfo, false);\n                }\n                function _getUpgradedConnection(dbInfo) {\n                    return _getConnection(dbInfo, true);\n                }\n                function _isUpgradeNeeded(dbInfo, defaultVersion) {\n                    if (!dbInfo.db) return true;\n                    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n                    var isDowngrade = dbInfo.version < dbInfo.db.version;\n                    var isUpgrade = dbInfo.version > dbInfo.db.version;\n                    if (isDowngrade) {\n                        // If the version is not the default one\n                        // then warn for impossible downgrade.\n                        if (dbInfo.version !== defaultVersion) console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + \" to version \" + dbInfo.version + \".\");\n                        // Align the versions to prevent errors.\n                        dbInfo.version = dbInfo.db.version;\n                    }\n                    if (isUpgrade || isNewStore) {\n                        // If the store is new then increment the version (if needed).\n                        // This will trigger an \"upgradeneeded\" event which is required\n                        // for creating a store.\n                        if (isNewStore) {\n                            var incVersion = dbInfo.db.version + 1;\n                            if (incVersion > dbInfo.version) dbInfo.version = incVersion;\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n                // encode a blob for indexeddb engines that don't support blobs\n                function _encodeBlob(blob) {\n                    return new Promise$1(function(resolve, reject) {\n                        var reader = new FileReader();\n                        reader.onerror = reject;\n                        reader.onloadend = function(e) {\n                            var base64 = btoa(e.target.result || \"\");\n                            resolve({\n                                __local_forage_encoded_blob: true,\n                                data: base64,\n                                type: blob.type\n                            });\n                        };\n                        reader.readAsBinaryString(blob);\n                    });\n                }\n                // decode an encoded blob\n                function _decodeBlob(encodedBlob) {\n                    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n                    return createBlob([\n                        arrayBuff\n                    ], {\n                        type: encodedBlob.type\n                    });\n                }\n                // is this one of our fancy encoded blobs?\n                function _isEncodedBlob(value) {\n                    return value && value.__local_forage_encoded_blob;\n                }\n                // Specialize the default `ready()` function by making it dependent\n                // on the current database operations. Thus, the driver will be actually\n                // ready when it's been initialized (default) *and* there are no pending\n                // operations on the database (initiated by some other instances).\n                function _fullyReady(callback) {\n                    var self1 = this;\n                    var promise = self1._initReady().then(function() {\n                        var dbContext = dbContexts[self1._dbInfo.name];\n                        if (dbContext && dbContext.dbReady) return dbContext.dbReady;\n                    });\n                    executeTwoCallbacks(promise, callback, callback);\n                    return promise;\n                }\n                // Try to establish a new db connection to replace the\n                // current one which is broken (i.e. experiencing\n                // InvalidStateError while creating a transaction).\n                function _tryReconnect(dbInfo) {\n                    _deferReadiness(dbInfo);\n                    var dbContext = dbContexts[dbInfo.name];\n                    var forages = dbContext.forages;\n                    for(var i = 0; i < forages.length; i++){\n                        var forage = forages[i];\n                        if (forage._dbInfo.db) {\n                            forage._dbInfo.db.close();\n                            forage._dbInfo.db = null;\n                        }\n                    }\n                    dbInfo.db = null;\n                    return _getOriginalConnection(dbInfo).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo)) // Reopen the database for upgrading.\n                        return _getUpgradedConnection(dbInfo);\n                        return db;\n                    }).then(function(db) {\n                        // store the latest db reference\n                        // in case the db was upgraded\n                        dbInfo.db = dbContext.db = db;\n                        for(var i = 0; i < forages.length; i++)forages[i]._dbInfo.db = db;\n                    })[\"catch\"](function(err) {\n                        _rejectReadiness(dbInfo, err);\n                        throw err;\n                    });\n                }\n                // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n                // so we have to do it with callbacks\n                function createTransaction(dbInfo, mode, callback, retries) {\n                    if (retries === undefined) retries = 1;\n                    try {\n                        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n                        callback(null, tx);\n                    } catch (err) {\n                        if (retries > 0 && (!dbInfo.db || err.name === \"InvalidStateError\" || err.name === \"NotFoundError\")) return Promise$1.resolve().then(function() {\n                            if (!dbInfo.db || err.name === \"NotFoundError\" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                                // increase the db version, to create the new ObjectStore\n                                if (dbInfo.db) dbInfo.version = dbInfo.db.version + 1;\n                                // Reopen the database for upgrading.\n                                return _getUpgradedConnection(dbInfo);\n                            }\n                        }).then(function() {\n                            return _tryReconnect(dbInfo).then(function() {\n                                createTransaction(dbInfo, mode, callback, retries - 1);\n                            });\n                        })[\"catch\"](callback);\n                        callback(err);\n                    }\n                }\n                function createDbContext() {\n                    return {\n                        // Running localForages sharing a database.\n                        forages: [],\n                        // Shared database.\n                        db: null,\n                        // Database readiness (promise).\n                        dbReady: null,\n                        // Deferred operations on the database.\n                        deferredOperations: []\n                    };\n                }\n                // Open the IndexedDB database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) for(var i in options)dbInfo[i] = options[i];\n                    // Get the current context of the database;\n                    var dbContext = dbContexts[dbInfo.name];\n                    // ...or create a new context.\n                    if (!dbContext) {\n                        dbContext = createDbContext();\n                        // Register the new context in the global container.\n                        dbContexts[dbInfo.name] = dbContext;\n                    }\n                    // Register itself as a running localForage in the current context.\n                    dbContext.forages.push(self1);\n                    // Replace the default `ready()` function with the specialized one.\n                    if (!self1._initReady) {\n                        self1._initReady = self1.ready;\n                        self1.ready = _fullyReady;\n                    }\n                    // Create an array of initialization states of the related localForages.\n                    var initPromises = [];\n                    function ignoreErrors() {\n                        // Don't handle errors here,\n                        // just makes sure related localForages aren't pending.\n                        return Promise$1.resolve();\n                    }\n                    for(var j = 0; j < dbContext.forages.length; j++){\n                        var forage = dbContext.forages[j];\n                        if (forage !== self1) // Don't wait for itself...\n                        initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n                    }\n                    // Take a snapshot of the related localForages.\n                    var forages = dbContext.forages.slice(0);\n                    // Initialize the connection process only when\n                    // all the related localForages aren't pending.\n                    return Promise$1.all(initPromises).then(function() {\n                        dbInfo.db = dbContext.db;\n                        // Get the connection or open a new one without upgrade.\n                        return _getOriginalConnection(dbInfo);\n                    }).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo, self1._defaultConfig.version)) // Reopen the database for upgrading.\n                        return _getUpgradedConnection(dbInfo);\n                        return db;\n                    }).then(function(db) {\n                        dbInfo.db = dbContext.db = db;\n                        self1._dbInfo = dbInfo;\n                        // Share the final connection amongst related localForages.\n                        for(var k = 0; k < forages.length; k++){\n                            var forage = forages[k];\n                            if (forage !== self1) {\n                                // Self is already up-to-date.\n                                forage._dbInfo.db = dbInfo.db;\n                                forage._dbInfo.version = dbInfo.version;\n                            }\n                        }\n                    });\n                }\n                function getItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.get(key);\n                                    req.onsuccess = function() {\n                                        var value = req.result;\n                                        if (value === undefined) value = null;\n                                        if (_isEncodedBlob(value)) value = _decodeBlob(value);\n                                        resolve(value);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items stored in database.\n                function iterate(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openCursor();\n                                    var iterationNumber = 1;\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (cursor) {\n                                            var value = cursor.value;\n                                            if (_isEncodedBlob(value)) value = _decodeBlob(value);\n                                            var result = iterator(value, cursor.key, iterationNumber++);\n                                            // when the iterator callback returns any\n                                            // (non-`undefined`) value, then we stop\n                                            // the iteration immediately\n                                            if (result !== void 0) resolve(result);\n                                            else cursor[\"continue\"]();\n                                        } else resolve();\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        var dbInfo;\n                        self1.ready().then(function() {\n                            dbInfo = self1._dbInfo;\n                            if (toString.call(value) === \"[object Blob]\") return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {\n                                if (blobSupport) return value;\n                                return _encodeBlob(value);\n                            });\n                            return value;\n                        }).then(function(value) {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // The reason we don't _save_ null is because IE 10 does\n                                    // not support saving the `null` type in IndexedDB. How\n                                    // ironic, given the bug below!\n                                    // See: https://github.com/mozilla/localForage/issues/161\n                                    if (value === null) value = undefined;\n                                    var req = store.put(value, key);\n                                    transaction.oncomplete = function() {\n                                        // Cast to undefined so the value passed to\n                                        // callback/promise is the same as what one would get out\n                                        // of `getItem()` later. This leads to some weirdness\n                                        // (setItem('foo', undefined) will return `null`), but\n                                        // it's not my fault localStorage is our baseline and that\n                                        // it's weird.\n                                        if (value === undefined) value = null;\n                                        resolve(value);\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function removeItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // We use a Grunt task to make this safe for IE and some\n                                    // versions of Android (including those used by Cordova).\n                                    // Normally IE won't like `.delete()` and will insist on\n                                    // using `['delete']()`, but we have a build step that\n                                    // fixes this for us now.\n                                    var req = store[\"delete\"](key);\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                    // The request will be also be aborted if we've exceeded our storage\n                                    // space.\n                                    transaction.onabort = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function clear(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.clear();\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function length(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.count();\n                                    req.onsuccess = function() {\n                                        resolve(req.result);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function key(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        if (n < 0) {\n                            resolve(null);\n                            return;\n                        }\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var advanced = false;\n                                    var req = store.openKeyCursor();\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            // this means there weren't enough keys\n                                            resolve(null);\n                                            return;\n                                        }\n                                        if (n === 0) // We have the first key, return it if that's what they\n                                        // wanted.\n                                        resolve(cursor.key);\n                                        else if (!advanced) {\n                                            // Otherwise, ask the cursor to skip ahead n\n                                            // records.\n                                            advanced = true;\n                                            cursor.advance(n);\n                                        } else // When we get here, we've got the nth key.\n                                        resolve(cursor.key);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) return reject(err);\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openKeyCursor();\n                                    var keys = [];\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            resolve(keys);\n                                            return;\n                                        }\n                                        keys.push(cursor.key);\n                                        cursor[\"continue\"]();\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) promise = Promise$1.reject(\"Invalid arguments\");\n                    else {\n                        var isCurrentDb = options.name === currentConfig.name && self1._dbInfo.db;\n                        var dbPromise = isCurrentDb ? Promise$1.resolve(self1._dbInfo.db) : _getOriginalConnection(options).then(function(db) {\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            dbContext.db = db;\n                            for(var i = 0; i < forages.length; i++)forages[i]._dbInfo.db = db;\n                            return db;\n                        });\n                        if (!options.storeName) promise = dbPromise.then(function(db) {\n                            _deferReadiness(options);\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            db.close();\n                            for(var i = 0; i < forages.length; i++){\n                                var forage = forages[i];\n                                forage._dbInfo.db = null;\n                            }\n                            var dropDBPromise = new Promise$1(function(resolve, reject) {\n                                var req = idb.deleteDatabase(options.name);\n                                req.onerror = function() {\n                                    var db = req.result;\n                                    if (db) db.close();\n                                    reject(req.error);\n                                };\n                                req.onblocked = function() {\n                                    // Closing all open connections in onversionchange handler should prevent this situation, but if\n                                    // we do get here, it just means the request remains pending - eventually it will succeed or error\n                                    console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                                };\n                                req.onsuccess = function() {\n                                    var db = req.result;\n                                    if (db) db.close();\n                                    resolve(db);\n                                };\n                            });\n                            return dropDBPromise.then(function(db) {\n                                dbContext.db = db;\n                                for(var i = 0; i < forages.length; i++){\n                                    var _forage = forages[i];\n                                    _advanceReadiness(_forage._dbInfo);\n                                }\n                            })[\"catch\"](function(err) {\n                                (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                throw err;\n                            });\n                        });\n                        else promise = dbPromise.then(function(db) {\n                            if (!db.objectStoreNames.contains(options.storeName)) return;\n                            var newVersion = db.version + 1;\n                            _deferReadiness(options);\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            db.close();\n                            for(var i = 0; i < forages.length; i++){\n                                var forage = forages[i];\n                                forage._dbInfo.db = null;\n                                forage._dbInfo.version = newVersion;\n                            }\n                            var dropObjectPromise = new Promise$1(function(resolve, reject) {\n                                var req = idb.open(options.name, newVersion);\n                                req.onerror = function(err) {\n                                    var db = req.result;\n                                    db.close();\n                                    reject(err);\n                                };\n                                req.onupgradeneeded = function() {\n                                    var db = req.result;\n                                    db.deleteObjectStore(options.storeName);\n                                };\n                                req.onsuccess = function() {\n                                    var db = req.result;\n                                    db.close();\n                                    resolve(db);\n                                };\n                            });\n                            return dropObjectPromise.then(function(db) {\n                                dbContext.db = db;\n                                for(var j = 0; j < forages.length; j++){\n                                    var _forage2 = forages[j];\n                                    _forage2._dbInfo.db = db;\n                                    _advanceReadiness(_forage2._dbInfo);\n                                }\n                            })[\"catch\"](function(err) {\n                                (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                throw err;\n                            });\n                        });\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var asyncStorage = {\n                    _driver: \"asyncStorage\",\n                    _initStorage: _initStorage,\n                    _support: isIndexedDBValid(),\n                    iterate: iterate,\n                    getItem: getItem,\n                    setItem: setItem,\n                    removeItem: removeItem,\n                    clear: clear,\n                    length: length,\n                    key: key,\n                    keys: keys,\n                    dropInstance: dropInstance\n                };\n                function isWebSQLValid() {\n                    return typeof openDatabase === \"function\";\n                }\n                // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n                // it to Base64, so this is how we store it to prevent very strange errors with less\n                // verbose ways of binary <-> string data storage.\n                var BASE_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n                var BLOB_TYPE_PREFIX = \"~~local_forage_type~\";\n                var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n                var SERIALIZED_MARKER = \"__lfsc__:\";\n                var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n                // OMG the serializations!\n                var TYPE_ARRAYBUFFER = \"arbf\";\n                var TYPE_BLOB = \"blob\";\n                var TYPE_INT8ARRAY = \"si08\";\n                var TYPE_UINT8ARRAY = \"ui08\";\n                var TYPE_UINT8CLAMPEDARRAY = \"uic8\";\n                var TYPE_INT16ARRAY = \"si16\";\n                var TYPE_INT32ARRAY = \"si32\";\n                var TYPE_UINT16ARRAY = \"ur16\";\n                var TYPE_UINT32ARRAY = \"ui32\";\n                var TYPE_FLOAT32ARRAY = \"fl32\";\n                var TYPE_FLOAT64ARRAY = \"fl64\";\n                var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n                var toString$1 = Object.prototype.toString;\n                function stringToBuffer(serializedString) {\n                    // Fill the string into a ArrayBuffer.\n                    var bufferLength = serializedString.length * 0.75;\n                    var len = serializedString.length;\n                    var i;\n                    var p = 0;\n                    var encoded1, encoded2, encoded3, encoded4;\n                    if (serializedString[serializedString.length - 1] === \"=\") {\n                        bufferLength--;\n                        if (serializedString[serializedString.length - 2] === \"=\") bufferLength--;\n                    }\n                    var buffer = new ArrayBuffer(bufferLength);\n                    var bytes = new Uint8Array(buffer);\n                    for(i = 0; i < len; i += 4){\n                        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n                        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n                        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n                        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n                        /*jslint bitwise: true */ bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n                        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n                        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n                    }\n                    return buffer;\n                }\n                // Converts a buffer to a string to store, serialized, in the backend\n                // storage library.\n                function bufferToString(buffer) {\n                    // base64-arraybuffer\n                    var bytes = new Uint8Array(buffer);\n                    var base64String = \"\";\n                    var i;\n                    for(i = 0; i < bytes.length; i += 3){\n                        /*jslint bitwise: true */ base64String += BASE_CHARS[bytes[i] >> 2];\n                        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n                        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n                        base64String += BASE_CHARS[bytes[i + 2] & 63];\n                    }\n                    if (bytes.length % 3 === 2) base64String = base64String.substring(0, base64String.length - 1) + \"=\";\n                    else if (bytes.length % 3 === 1) base64String = base64String.substring(0, base64String.length - 2) + \"==\";\n                    return base64String;\n                }\n                // Serialize a value, afterwards executing a callback (which usually\n                // instructs the `setItem()` callback/promise to be executed). This is how\n                // we store binary data with localStorage.\n                function serialize(value, callback) {\n                    var valueType = \"\";\n                    if (value) valueType = toString$1.call(value);\n                    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n                    // checks fail when running the tests using casper.js...\n                    //\n                    // TODO: See why those tests fail and use a better solution.\n                    if (value && (valueType === \"[object ArrayBuffer]\" || value.buffer && toString$1.call(value.buffer) === \"[object ArrayBuffer]\")) {\n                        // Convert binary arrays to a string and prefix the string with\n                        // a special marker.\n                        var buffer;\n                        var marker = SERIALIZED_MARKER;\n                        if (value instanceof ArrayBuffer) {\n                            buffer = value;\n                            marker += TYPE_ARRAYBUFFER;\n                        } else {\n                            buffer = value.buffer;\n                            if (valueType === \"[object Int8Array]\") marker += TYPE_INT8ARRAY;\n                            else if (valueType === \"[object Uint8Array]\") marker += TYPE_UINT8ARRAY;\n                            else if (valueType === \"[object Uint8ClampedArray]\") marker += TYPE_UINT8CLAMPEDARRAY;\n                            else if (valueType === \"[object Int16Array]\") marker += TYPE_INT16ARRAY;\n                            else if (valueType === \"[object Uint16Array]\") marker += TYPE_UINT16ARRAY;\n                            else if (valueType === \"[object Int32Array]\") marker += TYPE_INT32ARRAY;\n                            else if (valueType === \"[object Uint32Array]\") marker += TYPE_UINT32ARRAY;\n                            else if (valueType === \"[object Float32Array]\") marker += TYPE_FLOAT32ARRAY;\n                            else if (valueType === \"[object Float64Array]\") marker += TYPE_FLOAT64ARRAY;\n                            else callback(new Error(\"Failed to get type for BinaryArray\"));\n                        }\n                        callback(marker + bufferToString(buffer));\n                    } else if (valueType === \"[object Blob]\") {\n                        // Conver the blob to a binaryArray and then to a string.\n                        var fileReader = new FileReader();\n                        fileReader.onload = function() {\n                            // Backwards-compatible prefix for the blob type.\n                            var str = BLOB_TYPE_PREFIX + value.type + \"~\" + bufferToString(this.result);\n                            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n                        };\n                        fileReader.readAsArrayBuffer(value);\n                    } else try {\n                        callback(JSON.stringify(value));\n                    } catch (e) {\n                        console.error(\"Couldn't convert value into a JSON string: \", value);\n                        callback(null, e);\n                    }\n                }\n                // Deserialize data we've inserted into a value column/field. We place\n                // special markers into our strings to mark them as encoded; this isn't\n                // as nice as a meta field, but it's the only sane thing we can do whilst\n                // keeping localStorage support intact.\n                //\n                // Oftentimes this will just deserialize JSON content, but if we have a\n                // special marker (SERIALIZED_MARKER, defined above), we will extract\n                // some kind of arraybuffer/binary data/typed array out of the string.\n                function deserialize(value) {\n                    // If we haven't marked this string as being specially serialized (i.e.\n                    // something other than serialized JSON), we can just return it and be\n                    // done with it.\n                    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) return JSON.parse(value);\n                    // The following code deals with deserializing some kind of Blob or\n                    // TypedArray. First we separate out the type of data we're dealing\n                    // with from the data itself.\n                    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n                    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n                    var blobType;\n                    // Backwards-compatible blob type serialization strategy.\n                    // DBs created with older versions of localForage will simply not have the blob type.\n                    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n                        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n                        blobType = matcher[1];\n                        serializedString = serializedString.substring(matcher[0].length);\n                    }\n                    var buffer = stringToBuffer(serializedString);\n                    // Return the right type based on the code/type set during\n                    // serialization.\n                    switch(type){\n                        case TYPE_ARRAYBUFFER:\n                            return buffer;\n                        case TYPE_BLOB:\n                            return createBlob([\n                                buffer\n                            ], {\n                                type: blobType\n                            });\n                        case TYPE_INT8ARRAY:\n                            return new Int8Array(buffer);\n                        case TYPE_UINT8ARRAY:\n                            return new Uint8Array(buffer);\n                        case TYPE_UINT8CLAMPEDARRAY:\n                            return new Uint8ClampedArray(buffer);\n                        case TYPE_INT16ARRAY:\n                            return new Int16Array(buffer);\n                        case TYPE_UINT16ARRAY:\n                            return new Uint16Array(buffer);\n                        case TYPE_INT32ARRAY:\n                            return new Int32Array(buffer);\n                        case TYPE_UINT32ARRAY:\n                            return new Uint32Array(buffer);\n                        case TYPE_FLOAT32ARRAY:\n                            return new Float32Array(buffer);\n                        case TYPE_FLOAT64ARRAY:\n                            return new Float64Array(buffer);\n                        default:\n                            throw new Error(\"Unkown type: \" + type);\n                    }\n                }\n                var localforageSerializer = {\n                    serialize: serialize,\n                    deserialize: deserialize,\n                    stringToBuffer: stringToBuffer,\n                    bufferToString: bufferToString\n                };\n                /*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */ function createDbTable(t, dbInfo, callback, errorCallback) {\n                    t.executeSql(\"CREATE TABLE IF NOT EXISTS \" + dbInfo.storeName + \" \" + \"(id INTEGER PRIMARY KEY, key unique, value)\", [], callback, errorCallback);\n                }\n                // Open the WebSQL database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage$1(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) for(var i in options)dbInfo[i] = typeof options[i] !== \"string\" ? options[i].toString() : options[i];\n                    var dbInfoPromise = new Promise$1(function(resolve, reject) {\n                        // Open the database; the openDatabase API will automatically\n                        // create it for us if it doesn't exist.\n                        try {\n                            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // Create our key/value table if it doesn't exist.\n                        dbInfo.db.transaction(function(t) {\n                            createDbTable(t, dbInfo, function() {\n                                self1._dbInfo = dbInfo;\n                                resolve();\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, reject);\n                    });\n                    dbInfo.serializer = localforageSerializer;\n                    return dbInfoPromise;\n                }\n                function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n                    t.executeSql(sqlStatement, args, callback, function(t, error) {\n                        if (error.code === error.SYNTAX_ERR) t.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name = ?\", [\n                            dbInfo.storeName\n                        ], function(t, results) {\n                            if (!results.rows.length) // if the table is missing (was deleted)\n                            // re-create it table and retry\n                            createDbTable(t, dbInfo, function() {\n                                t.executeSql(sqlStatement, args, callback, errorCallback);\n                            }, errorCallback);\n                            else errorCallback(t, error);\n                        }, errorCallback);\n                        else errorCallback(t, error);\n                    }, errorCallback);\n                }\n                function getItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName + \" WHERE key = ? LIMIT 1\", [\n                                    key\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).value : null;\n                                    // Check to see if this is serialized content we need to\n                                    // unpack.\n                                    if (result) result = dbInfo.serializer.deserialize(result);\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function iterate$1(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var rows = results.rows;\n                                    var length = rows.length;\n                                    for(var i = 0; i < length; i++){\n                                        var item = rows.item(i);\n                                        var result = item.value;\n                                        // Check to see if this is serialized content\n                                        // we need to unpack.\n                                        if (result) result = dbInfo.serializer.deserialize(result);\n                                        result = iterator(result, item.key, i + 1);\n                                        // void(0) prevents problems with redefinition\n                                        // of `undefined`.\n                                        if (result !== void 0) {\n                                            resolve(result);\n                                            return;\n                                        }\n                                    }\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function _setItem(key, value, callback, retriesLeft) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            // The localStorage API doesn't return undefined values in an\n                            // \"expected\" way, so undefined is always cast to null in all\n                            // drivers. See: https://github.com/mozilla/localForage/pull/42\n                            if (value === undefined) value = null;\n                            // Save the original value to pass to the callback.\n                            var originalValue = value;\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) reject(error);\n                                else dbInfo.db.transaction(function(t) {\n                                    tryExecuteSql(t, dbInfo, \"INSERT OR REPLACE INTO \" + dbInfo.storeName + \" \" + \"(key, value) VALUES (?, ?)\", [\n                                        key,\n                                        value\n                                    ], function() {\n                                        resolve(originalValue);\n                                    }, function(t, error) {\n                                        reject(error);\n                                    });\n                                }, function(sqlError) {\n                                    // The transaction failed; check\n                                    // to see if it's a quota error.\n                                    if (sqlError.code === sqlError.QUOTA_ERR) {\n                                        // We reject the callback outright for now, but\n                                        // it's worth trying to re-run the transaction.\n                                        // Even if the user accepts the prompt to use\n                                        // more storage on Safari, this error will\n                                        // be called.\n                                        //\n                                        // Try to re-run the transaction.\n                                        if (retriesLeft > 0) {\n                                            resolve(_setItem.apply(self1, [\n                                                key,\n                                                originalValue,\n                                                callback,\n                                                retriesLeft - 1\n                                            ]));\n                                            return;\n                                        }\n                                        reject(sqlError);\n                                    }\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem$1(key, value, callback) {\n                    return _setItem.apply(this, [\n                        key,\n                        value,\n                        callback,\n                        1\n                    ]);\n                }\n                function removeItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName + \" WHERE key = ?\", [\n                                    key\n                                ], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Deletes every item in the table.\n                // TODO: Find out if this resets the AUTO_INCREMENT number.\n                function clear$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName, [], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Does a simple `COUNT(key)` to get the number of items stored in\n                // localForage.\n                function length$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                // Ahhh, SQL makes this one soooooo easy.\n                                tryExecuteSql(t, dbInfo, \"SELECT COUNT(key) as c FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var result = results.rows.item(0).c;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Return the key located at key index X; essentially gets the key from a\n                // `WHERE id = ?`. This is the most efficient way I can think to implement\n                // this rarely-used (in my experience) part of the API, but it can seem\n                // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n                // the ID of each key will change every time it's updated. Perhaps a stored\n                // procedure for the `setItem()` SQL would solve this problem?\n                // TODO: Don't change ID on `setItem()`.\n                function key$1(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName + \" WHERE id = ? LIMIT 1\", [\n                                    n + 1\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).key : null;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var keys = [];\n                                    for(var i = 0; i < results.rows.length; i++)keys.push(results.rows.item(i).key);\n                                    resolve(keys);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // https://www.w3.org/TR/webdatabase/#databases\n                // > There is no way to enumerate or delete the databases available for an origin from this API.\n                function getAllStoreNames(db) {\n                    return new Promise$1(function(resolve, reject) {\n                        db.transaction(function(t) {\n                            t.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function(t, results) {\n                                var storeNames = [];\n                                for(var i = 0; i < results.rows.length; i++)storeNames.push(results.rows.item(i).name);\n                                resolve({\n                                    db: db,\n                                    storeNames: storeNames\n                                });\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, function(sqlError) {\n                            reject(sqlError);\n                        });\n                    });\n                }\n                function dropInstance$1(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) promise = Promise$1.reject(\"Invalid arguments\");\n                    else promise = new Promise$1(function(resolve) {\n                        var db;\n                        if (options.name === currentConfig.name) // use the db reference of the current instance\n                        db = self1._dbInfo.db;\n                        else db = openDatabase(options.name, \"\", \"\", 0);\n                        if (!options.storeName) // drop all database tables\n                        resolve(getAllStoreNames(db));\n                        else resolve({\n                            db: db,\n                            storeNames: [\n                                options.storeName\n                            ]\n                        });\n                    }).then(function(operationInfo) {\n                        return new Promise$1(function(resolve, reject) {\n                            operationInfo.db.transaction(function(t) {\n                                function dropTable(storeName) {\n                                    return new Promise$1(function(resolve, reject) {\n                                        t.executeSql(\"DROP TABLE IF EXISTS \" + storeName, [], function() {\n                                            resolve();\n                                        }, function(t, error) {\n                                            reject(error);\n                                        });\n                                    });\n                                }\n                                var operations = [];\n                                for(var i = 0, len = operationInfo.storeNames.length; i < len; i++)operations.push(dropTable(operationInfo.storeNames[i]));\n                                Promise$1.all(operations).then(function() {\n                                    resolve();\n                                })[\"catch\"](function(e) {\n                                    reject(e);\n                                });\n                            }, function(sqlError) {\n                                reject(sqlError);\n                            });\n                        });\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var webSQLStorage = {\n                    _driver: \"webSQLStorage\",\n                    _initStorage: _initStorage$1,\n                    _support: isWebSQLValid(),\n                    iterate: iterate$1,\n                    getItem: getItem$1,\n                    setItem: setItem$1,\n                    removeItem: removeItem$1,\n                    clear: clear$1,\n                    length: length$1,\n                    key: key$1,\n                    keys: keys$1,\n                    dropInstance: dropInstance$1\n                };\n                function isLocalStorageValid() {\n                    try {\n                        return typeof localStorage !== \"undefined\" && \"setItem\" in localStorage && // in IE8 typeof localStorage.setItem === 'object'\n                        !!localStorage.setItem;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                function _getKeyPrefix(options, defaultConfig) {\n                    var keyPrefix = options.name + \"/\";\n                    if (options.storeName !== defaultConfig.storeName) keyPrefix += options.storeName + \"/\";\n                    return keyPrefix;\n                }\n                // Check if localStorage throws when saving an item\n                function checkIfLocalStorageThrows() {\n                    var localStorageTestKey = \"_localforage_support_test\";\n                    try {\n                        localStorage.setItem(localStorageTestKey, true);\n                        localStorage.removeItem(localStorageTestKey);\n                        return false;\n                    } catch (e) {\n                        return true;\n                    }\n                }\n                // Check if localStorage is usable and allows to save an item\n                // This method checks if localStorage is usable in Safari Private Browsing\n                // mode, or in any other case where the available quota for localStorage\n                // is 0 and there wasn't any saved items yet.\n                function _isLocalStorageUsable() {\n                    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n                }\n                // Config the localStorage backend, using options set in the config.\n                function _initStorage$2(options) {\n                    var self1 = this;\n                    var dbInfo = {};\n                    if (options) for(var i in options)dbInfo[i] = options[i];\n                    dbInfo.keyPrefix = _getKeyPrefix(options, self1._defaultConfig);\n                    if (!_isLocalStorageUsable()) return Promise$1.reject();\n                    self1._dbInfo = dbInfo;\n                    dbInfo.serializer = localforageSerializer;\n                    return Promise$1.resolve();\n                }\n                // Remove all keys from the datastore, effectively destroying all data in\n                // the app's key/value store!\n                function clear$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var keyPrefix = self1._dbInfo.keyPrefix;\n                        for(var i = localStorage.length - 1; i >= 0; i--){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) === 0) localStorage.removeItem(key);\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Retrieve an item from the store. Unlike the original async_storage\n                // library in Gaia, we don't modify return values at all. If a key's value\n                // is `undefined`, we pass that value to the callback function.\n                function getItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n                        // If a result was found, parse it from the serialized\n                        // string into a JS object. If result isn't truthy, the key\n                        // is likely undefined and we'll pass it straight to the\n                        // callback.\n                        if (result) result = dbInfo.serializer.deserialize(result);\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items in the store.\n                function iterate$2(iterator, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var keyPrefix = dbInfo.keyPrefix;\n                        var keyPrefixLength = keyPrefix.length;\n                        var length = localStorage.length;\n                        // We use a dedicated iterator instead of the `i` variable below\n                        // so other keys we fetch in localStorage aren't counted in\n                        // the `iterationNumber` argument passed to the `iterate()`\n                        // callback.\n                        //\n                        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n                        var iterationNumber = 1;\n                        for(var i = 0; i < length; i++){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) !== 0) continue;\n                            var value = localStorage.getItem(key);\n                            // If a result was found, parse it from the serialized\n                            // string into a JS object. If result isn't truthy, the\n                            // key is likely undefined and we'll pass it straight\n                            // to the iterator.\n                            if (value) value = dbInfo.serializer.deserialize(value);\n                            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n                            if (value !== void 0) return value;\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Same as localStorage's key() method, except takes a callback.\n                function key$2(n, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result;\n                        try {\n                            result = localStorage.key(n);\n                        } catch (error) {\n                            result = null;\n                        }\n                        // Remove the prefix from the key, if a key is found.\n                        if (result) result = result.substring(dbInfo.keyPrefix.length);\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var length = localStorage.length;\n                        var keys = [];\n                        for(var i = 0; i < length; i++){\n                            var itemKey = localStorage.key(i);\n                            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n                        }\n                        return keys;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Supply the number of keys in the datastore to the callback function.\n                function length$2(callback) {\n                    var self1 = this;\n                    var promise = self1.keys().then(function(keys) {\n                        return keys.length;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Remove an item from the store, nice and simple.\n                function removeItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        localStorage.removeItem(dbInfo.keyPrefix + key);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Set a key's value and run an optional callback once the value is set.\n                // Unlike Gaia's implementation, the callback function is passed the value,\n                // in case you want to operate on that value only after you're sure it\n                // saved, or something like that.\n                function setItem$2(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        // Convert undefined values to null.\n                        // https://github.com/mozilla/localForage/pull/42\n                        if (value === undefined) value = null;\n                        // Save the original value to pass to the callback.\n                        var originalValue = value;\n                        return new Promise$1(function(resolve, reject) {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) reject(error);\n                                else try {\n                                    localStorage.setItem(dbInfo.keyPrefix + key, value);\n                                    resolve(originalValue);\n                                } catch (e) {\n                                    // localStorage capacity exceeded.\n                                    // TODO: Make this a specific error/event.\n                                    if (e.name === \"QuotaExceededError\" || e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") reject(e);\n                                    reject(e);\n                                }\n                            });\n                        });\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance$2(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        var currentConfig = this.config();\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) promise = Promise$1.reject(\"Invalid arguments\");\n                    else promise = new Promise$1(function(resolve) {\n                        if (!options.storeName) resolve(options.name + \"/\");\n                        else resolve(_getKeyPrefix(options, self1._defaultConfig));\n                    }).then(function(keyPrefix) {\n                        for(var i = localStorage.length - 1; i >= 0; i--){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) === 0) localStorage.removeItem(key);\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var localStorageWrapper = {\n                    _driver: \"localStorageWrapper\",\n                    _initStorage: _initStorage$2,\n                    _support: isLocalStorageValid(),\n                    iterate: iterate$2,\n                    getItem: getItem$2,\n                    setItem: setItem$2,\n                    removeItem: removeItem$2,\n                    clear: clear$2,\n                    length: length$2,\n                    key: key$2,\n                    keys: keys$2,\n                    dropInstance: dropInstance$2\n                };\n                var sameValue = function sameValue(x, y) {\n                    return x === y || typeof x === \"number\" && typeof y === \"number\" && isNaN(x) && isNaN(y);\n                };\n                var includes = function includes(array, searchElement) {\n                    var len = array.length;\n                    var i = 0;\n                    while(i < len){\n                        if (sameValue(array[i], searchElement)) return true;\n                        i++;\n                    }\n                    return false;\n                };\n                var isArray = Array.isArray || function(arg) {\n                    return Object.prototype.toString.call(arg) === \"[object Array]\";\n                };\n                // Drivers are stored here when `defineDriver()` is called.\n                // They are shared across all instances of localForage.\n                var DefinedDrivers = {};\n                var DriverSupport = {};\n                var DefaultDrivers = {\n                    INDEXEDDB: asyncStorage,\n                    WEBSQL: webSQLStorage,\n                    LOCALSTORAGE: localStorageWrapper\n                };\n                var DefaultDriverOrder = [\n                    DefaultDrivers.INDEXEDDB._driver,\n                    DefaultDrivers.WEBSQL._driver,\n                    DefaultDrivers.LOCALSTORAGE._driver\n                ];\n                var OptionalDriverMethods = [\n                    \"dropInstance\"\n                ];\n                var LibraryMethods = [\n                    \"clear\",\n                    \"getItem\",\n                    \"iterate\",\n                    \"key\",\n                    \"keys\",\n                    \"length\",\n                    \"removeItem\",\n                    \"setItem\"\n                ].concat(OptionalDriverMethods);\n                var DefaultConfig = {\n                    description: \"\",\n                    driver: DefaultDriverOrder.slice(),\n                    name: \"localforage\",\n                    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n                    // we can use without a prompt.\n                    size: 4980736,\n                    storeName: \"keyvaluepairs\",\n                    version: 1.0\n                };\n                function callWhenReady(localForageInstance, libraryMethod) {\n                    localForageInstance[libraryMethod] = function() {\n                        var _args = arguments;\n                        return localForageInstance.ready().then(function() {\n                            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n                        });\n                    };\n                }\n                function extend() {\n                    for(var i = 1; i < arguments.length; i++){\n                        var arg = arguments[i];\n                        if (arg) {\n                            for(var _key in arg)if (arg.hasOwnProperty(_key)) {\n                                if (isArray(arg[_key])) arguments[0][_key] = arg[_key].slice();\n                                else arguments[0][_key] = arg[_key];\n                            }\n                        }\n                    }\n                    return arguments[0];\n                }\n                var LocalForage = function() {\n                    function LocalForage(options) {\n                        _classCallCheck(this, LocalForage);\n                        for(var driverTypeKey in DefaultDrivers)if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                            var driver = DefaultDrivers[driverTypeKey];\n                            var driverName = driver._driver;\n                            this[driverTypeKey] = driverName;\n                            if (!DefinedDrivers[driverName]) // we don't need to wait for the promise,\n                            // since the default drivers can be defined\n                            // in a blocking manner\n                            this.defineDriver(driver);\n                        }\n                        this._defaultConfig = extend({}, DefaultConfig);\n                        this._config = extend({}, this._defaultConfig, options);\n                        this._driverSet = null;\n                        this._initDriver = null;\n                        this._ready = false;\n                        this._dbInfo = null;\n                        this._wrapLibraryMethodsWithReady();\n                        this.setDriver(this._config.driver)[\"catch\"](function() {});\n                    }\n                    // Set any config values for localForage; can be called anytime before\n                    // the first API call (e.g. `getItem`, `setItem`).\n                    // We loop through options so we don't overwrite existing config\n                    // values.\n                    LocalForage.prototype.config = function config(options) {\n                        // If the options argument is an object, we use it to set values.\n                        // Otherwise, we return either a specified config value or all\n                        // config values.\n                        if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) === \"object\") {\n                            // If localforage is ready and fully initialized, we can't set\n                            // any new configuration values. Instead, we return an error.\n                            if (this._ready) return new Error(\"Can't call config() after localforage has been used.\");\n                            for(var i in options){\n                                if (i === \"storeName\") options[i] = options[i].replace(/\\W/g, \"_\");\n                                if (i === \"version\" && typeof options[i] !== \"number\") return new Error(\"Database version must be a number.\");\n                                this._config[i] = options[i];\n                            }\n                            // after all config options are set and\n                            // the driver option is used, try setting it\n                            if (\"driver\" in options && options.driver) return this.setDriver(this._config.driver);\n                            return true;\n                        } else if (typeof options === \"string\") return this._config[options];\n                        else return this._config;\n                    };\n                    // Used to define a custom driver, shared across all instances of\n                    // localForage.\n                    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n                        var promise = new Promise$1(function(resolve, reject) {\n                            try {\n                                var driverName = driverObject._driver;\n                                var complianceError = new Error(\"Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver\");\n                                // A driver name should be defined and not overlap with the\n                                // library-defined, default drivers.\n                                if (!driverObject._driver) {\n                                    reject(complianceError);\n                                    return;\n                                }\n                                var driverMethods = LibraryMethods.concat(\"_initStorage\");\n                                for(var i = 0, len = driverMethods.length; i < len; i++){\n                                    var driverMethodName = driverMethods[i];\n                                    // when the property is there,\n                                    // it should be a method even when optional\n                                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== \"function\") {\n                                        reject(complianceError);\n                                        return;\n                                    }\n                                }\n                                var configureMissingMethods = function configureMissingMethods() {\n                                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                                        return function() {\n                                            var error = new Error(\"Method \" + methodName + \" is not implemented by the current driver\");\n                                            var promise = Promise$1.reject(error);\n                                            executeCallback(promise, arguments[arguments.length - 1]);\n                                            return promise;\n                                        };\n                                    };\n                                    for(var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++){\n                                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                                        if (!driverObject[optionalDriverMethod]) driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                                    }\n                                };\n                                configureMissingMethods();\n                                var setDriverSupport = function setDriverSupport(support) {\n                                    if (DefinedDrivers[driverName]) console.info(\"Redefining LocalForage driver: \" + driverName);\n                                    DefinedDrivers[driverName] = driverObject;\n                                    DriverSupport[driverName] = support;\n                                    // don't use a then, so that we can define\n                                    // drivers that have simple _support methods\n                                    // in a blocking manner\n                                    resolve();\n                                };\n                                if (\"_support\" in driverObject) {\n                                    if (driverObject._support && typeof driverObject._support === \"function\") driverObject._support().then(setDriverSupport, reject);\n                                    else setDriverSupport(!!driverObject._support);\n                                } else setDriverSupport(true);\n                            } catch (e) {\n                                reject(e);\n                            }\n                        });\n                        executeTwoCallbacks(promise, callback, errorCallback);\n                        return promise;\n                    };\n                    LocalForage.prototype.driver = function driver() {\n                        return this._driver || null;\n                    };\n                    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n                        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error(\"Driver not found.\"));\n                        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n                        return getDriverPromise;\n                    };\n                    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n                        var serializerPromise = Promise$1.resolve(localforageSerializer);\n                        executeTwoCallbacks(serializerPromise, callback);\n                        return serializerPromise;\n                    };\n                    LocalForage.prototype.ready = function ready(callback) {\n                        var self1 = this;\n                        var promise = self1._driverSet.then(function() {\n                            if (self1._ready === null) self1._ready = self1._initDriver();\n                            return self1._ready;\n                        });\n                        executeTwoCallbacks(promise, callback, callback);\n                        return promise;\n                    };\n                    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n                        var self1 = this;\n                        if (!isArray(drivers)) drivers = [\n                            drivers\n                        ];\n                        var supportedDrivers = this._getSupportedDrivers(drivers);\n                        function setDriverToConfig() {\n                            self1._config.driver = self1.driver();\n                        }\n                        function extendSelfWithDriver(driver) {\n                            self1._extend(driver);\n                            setDriverToConfig();\n                            self1._ready = self1._initStorage(self1._config);\n                            return self1._ready;\n                        }\n                        function initDriver(supportedDrivers) {\n                            return function() {\n                                var currentDriverIndex = 0;\n                                function driverPromiseLoop() {\n                                    while(currentDriverIndex < supportedDrivers.length){\n                                        var driverName = supportedDrivers[currentDriverIndex];\n                                        currentDriverIndex++;\n                                        self1._dbInfo = null;\n                                        self1._ready = null;\n                                        return self1.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                                    }\n                                    setDriverToConfig();\n                                    var error = new Error(\"No available storage method found.\");\n                                    self1._driverSet = Promise$1.reject(error);\n                                    return self1._driverSet;\n                                }\n                                return driverPromiseLoop();\n                            };\n                        }\n                        // There might be a driver initialization in progress\n                        // so wait for it to finish in order to avoid a possible\n                        // race condition to set _dbInfo\n                        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function() {\n                            return Promise$1.resolve();\n                        }) : Promise$1.resolve();\n                        this._driverSet = oldDriverSetDone.then(function() {\n                            var driverName = supportedDrivers[0];\n                            self1._dbInfo = null;\n                            self1._ready = null;\n                            return self1.getDriver(driverName).then(function(driver) {\n                                self1._driver = driver._driver;\n                                setDriverToConfig();\n                                self1._wrapLibraryMethodsWithReady();\n                                self1._initDriver = initDriver(supportedDrivers);\n                            });\n                        })[\"catch\"](function() {\n                            setDriverToConfig();\n                            var error = new Error(\"No available storage method found.\");\n                            self1._driverSet = Promise$1.reject(error);\n                            return self1._driverSet;\n                        });\n                        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n                        return this._driverSet;\n                    };\n                    LocalForage.prototype.supports = function supports(driverName) {\n                        return !!DriverSupport[driverName];\n                    };\n                    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n                        extend(this, libraryMethodsAndProperties);\n                    };\n                    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n                        var supportedDrivers = [];\n                        for(var i = 0, len = drivers.length; i < len; i++){\n                            var driverName = drivers[i];\n                            if (this.supports(driverName)) supportedDrivers.push(driverName);\n                        }\n                        return supportedDrivers;\n                    };\n                    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n                        // Add a stub for each driver API method that delays the call to the\n                        // corresponding driver method until localForage is ready. These stubs\n                        // will be replaced by the driver methods as soon as the driver is\n                        // loaded, so there is no performance impact.\n                        for(var i = 0, len = LibraryMethods.length; i < len; i++)callWhenReady(this, LibraryMethods[i]);\n                    };\n                    LocalForage.prototype.createInstance = function createInstance(options) {\n                        return new LocalForage(options);\n                    };\n                    return LocalForage;\n                }();\n                // The actual localForage object that we expose as a module or via a\n                // global. It's extended by pulling in one of our other libraries.\n                var localforage_js = new LocalForage();\n                module1.exports = localforage_js;\n            },\n            {\n                \"3\": 3\n            }\n        ]\n    }, {}, [\n        4\n    ])(4);\n});\n\n\nclass $2be32918d126bef2$export$5bfce22a6398152d {\n    constructor(game){\n        this.game = game;\n        console.log(\"Save Manager Constructor\");\n        console.log(this.game);\n    }\n    async save(game) {\n        this.game = game;\n        console.log(\"Saving game\");\n        console.log(this.game);\n        const stateToSave = {};\n        stateToSave[\"points\"] = this.game.points;\n        stateToSave[\"visibleLayer\"] = this.game.visibleLayer;\n        stateToSave[\"mainInterval\"] = this.game.mainInterval;\n        stateToSave[\"fixedInterval\"] = this.game.fixedInterval;\n        stateToSave[\"highestPoints\"] = this.game.highestPoints;\n        stateToSave[\"tooltipsEnabled\"] = this.game.tooltipsEnabled;\n        stateToSave[\"layers\"] = {\n            start: {\n                unlocked: this.game.layers.start.unlocked,\n                cost: this.game.layers.start.cost,\n                milestones: parseMilestones(this.game.layers.start.milestones)\n            },\n            dice: {\n                unlocked: this.game.layers.dice.unlocked,\n                cost: this.game.layers.dice.cost,\n                milestones: parseMilestones(this.game.layers.dice.milestones)\n            },\n            coin: {\n                unlocked: this.game.layers.coin.unlocked,\n                cost: this.game.layers.coin.cost,\n                milestones: parseMilestones(this.game.layers.coin.milestones)\n            }\n        };\n        // Parse the milestones to save them, Remove the function code and reference the function by name\n        function parseMilestones(milestones) {\n            const parsedMilestones = {};\n            for (const key of Object.keys(milestones)){\n                const milestone = milestones[key];\n                for (const milestoneKey of Object.keys(milestone)){\n                    if (milestoneKey === \"function\") {\n                        console.log(milestone[milestoneKey]);\n                        milestone[milestoneKey] = milestone[milestoneKey].name;\n                    }\n                    if (milestoneKey === \"unlockPoints\") milestone[milestoneKey] = parseInt(milestone[milestoneKey]);\n                }\n                parsedMilestones[key] = milestone;\n            }\n            return parsedMilestones;\n        }\n        // Actually save the state\n        try {\n            console.log(\"Saving game state\", stateToSave);\n            await (0, (/*@__PURE__*/$parcel$interopDefault($26ce26772c045640$exports))).setItem(\"gameState\", stateToSave);\n        } catch (err) {\n            console.error(\"Save failed\", err);\n        }\n    }\n    async load(game) {\n        this.game = game;\n        try {\n            const gameState = await (0, (/*@__PURE__*/$parcel$interopDefault($26ce26772c045640$exports))).getItem(\"gameState\");\n            console.log(\"STATE LOAD: \", gameState);\n            // Sets the milestones function to the actual function. This is done because the function is not saved in the save file\n            function parseMilestones(thisGame, milestones) {\n                const parsedMilestones = {};\n                // Loop over each actual Milestone\n                for (const key of Object.keys(milestones)){\n                    const milestone = milestones[key];\n                    // Loop over each value in the milestone\n                    for (const milestoneKey of Object.keys(milestone))// If it is a function, set the milestone to the actual function\n                    if (milestoneKey === \"function\") milestone[milestoneKey] = thisGame.milestoneFunctions[milestone[milestoneKey]];\n                    else milestone[milestoneKey] = milestone[milestoneKey];\n                    parsedMilestones[key] = milestone;\n                }\n                return parsedMilestones;\n            }\n            if (gameState) {\n                this.game.points = gameState.points;\n                this.game.visibleLayer = gameState.visibleLayer;\n                this.game.mainInterval = gameState.mainInterval;\n                this.game.fixedInterval = gameState.fixedInterval;\n                this.game.highestPoints = gameState.highestPoints;\n                this.game.tooltipsEnabled = gameState.tooltipsEnabled;\n                this.game.layers.start.unlocked = gameState.layers.start.unlocked;\n                this.game.layers.start.cost = gameState.layers.start.cost;\n                this.game.layers.start.milestones = parseMilestones(this.game.layers.start, gameState.layers.start.milestones);\n                this.game.layers.dice.unlocked = gameState.layers.dice.unlocked;\n                this.game.layers.dice.cost = gameState.layers.dice.cost;\n                this.game.layers.dice.milestones = parseMilestones(this.game.layers.dice, gameState.layers.dice.milestones);\n                this.game.layers.coin.unlocked = gameState.layers.coin.unlocked;\n                this.game.layers.coin.cost = gameState.layers.coin.cost;\n                this.game.layers.coin.milestones = parseMilestones(this.game.layers.coin, gameState.layers.coin.milestones);\n                this.game.setupNav();\n                for (const layer of Object.keys(this.game.layers))this.game.layers[layer].toggleVisibility(true);\n                this.game.switchLayer(this.game.visibleLayer);\n                this.game.setTooltipsState();\n                this.game.updateUI();\n            } else {\n                console.log(\"No saved game state to load\");\n                this.save(this.game); // Save initial state if nothing to load\n            }\n        } catch (err) {\n            console.error(\"Load failed\", err);\n        }\n    }\n}\n\n\nclass $2e57933e65d9ec74$export$353f5b6fc5456de1 {\n    constructor(name, txt, callback, css = \"\"){\n        this.buttonCSS = \"bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded w-1/4 mx-auto mt-4\";\n        this.buttonCSS = css ? css : this.buttonCSS;\n        this.name = name;\n        this.txt = txt;\n        this.description = \"\";\n        this.callback = callback;\n        this.button = document.createElement(\"button\");\n        this.init();\n    }\n    init() {\n        this.button.textContent = this.txt;\n        this.button.className = this.buttonCSS;\n        this.button.addEventListener(\"click\", this.callback);\n        this.button.setAttribute(\"tooltipenabled\", \"enabled\");\n        // Tooltip\n        this.button.addEventListener(\"mouseover\", (event)=>{\n            if (this.button.getAttribute(\"tooltipenabled\") !== \"enabled\") return;\n            const descriptionDiv = document.createElement(\"div\");\n            descriptionDiv.textContent = this.description;\n            descriptionDiv.className = \"absolute bg-gray-900 p-2 rounded z-10 font-bold\"; // z-10 to ensure it's above other items\n            document.body.appendChild(descriptionDiv); // Append to body to ensure it's not constrained by button's position\n            const updateTooltipPosition = (mouseEvent)=>{\n                descriptionDiv.style.left = `${mouseEvent.clientX + 10}px`; // +10 for a slight offset from the cursor\n                descriptionDiv.style.top = `${mouseEvent.clientY + 10}px`;\n            };\n            // Initial position update\n            updateTooltipPosition(event);\n            // Update tooltip position on mouse move\n            this.button.addEventListener(\"mousemove\", updateTooltipPosition);\n            // Clean up: remove tooltip and event listener when mouse leaves\n            this.button.addEventListener(\"mouseleave\", ()=>{\n                descriptionDiv.remove();\n                this.button.removeEventListener(\"mousemove\", updateTooltipPosition);\n            }, {\n                once: true\n            }); // Use { once: true } to automatically remove this event listener after it triggers once\n        });\n        return this.button;\n    }\n    // Optionally, create a static factory method to directly return the button element\n    static createButton(name, txt, callback, css = \"\") {\n        const btn = new $2e57933e65d9ec74$export$353f5b6fc5456de1(name, txt, callback, css);\n        return btn.button;\n    }\n    // Optionally, create a static factory method to directly return the button element\n    static createMilestoneButton(milestone, css = \"\") {\n        const btn = new $2e57933e65d9ec74$export$353f5b6fc5456de1(milestone.name, milestone.text, milestone.function, css);\n        btn.description = milestone.description;\n        return btn.button;\n    }\n}\n\n\n// bind document.getElementById to $\nconst $b5b828a44d183c86$var$$ = document.getElementById.bind(document);\nclass $b5b828a44d183c86$export$936d0764594b6eb3 {\n    constructor(game, name, cost, layerColor){\n        this.unlocked = false;\n        this.parentElement = $b5b828a44d183c86$var$$(\"main\");\n        this.visible = false;\n        this.Button = (0, $2e57933e65d9ec74$export$353f5b6fc5456de1);\n        this.game = game;\n        this.name = name;\n        this.cost = cost;\n        this.layerColor = layerColor;\n        this.milestones = {\n        };\n        // this.milestonesUnlocked = {};\n        this.milestoneFunctions = {\n            \"test\": ()=>{\n                console.log(\"Test Milestone\");\n                console.log(\"End Test Milestone\");\n            }\n        };\n        // create a blank div that fills the entire parent, and add it to the parent which is main\n        this.div = document.createElement(\"div\");\n        this.parentElement.appendChild(this.div);\n        this.div.classList.add(\"flex\", \"flex-col\", \"w-full\", \"h-full\", \"hidden\");\n        this.div.setAttribute(\"id\", this.name);\n        // create a title for the layer\n        this.layerTitle = document.createElement(\"div\");\n        this.div.appendChild(this.layerTitle);\n        this.layerTitle.innerText = this.name.toUpperCase();\n        this.layerTitle.classList.add(\"text-2xl\", \"text-center\", \"mb-4\", \"font-bold\", \"w-full\", \"border-b-2\", `border-${this.layerColor}-500`);\n        this.elements = {};\n    }\n    tryUnlock(currentPoints) {\n        // console.log(\"Trying to unlock\", this.name, \"with\", currentPoints, \"/\", this.cost, \"points\");\n        if (currentPoints >= this.cost) {\n            this.unlocked = true;\n            console.log(\"Unlocked Layer\", this.name);\n            return true;\n        } else return false;\n    }\n    toggleVisibility(forceHide) {\n        if (forceHide) {\n            if (this.div.classList.contains(\"hidden\")) {\n                this.visible = false;\n                return;\n            } else {\n                this.div.classList.add(\"hidden\");\n                this.visible = false;\n                return;\n            }\n        } else if (this.visible) {\n            this.div.classList.add(\"hidden\");\n            this.visible = false;\n        } else {\n            this.div.classList.remove(\"hidden\");\n            this.visible = true;\n        }\n    }\n    checkMilestones() {\n        for (const key of Object.keys(this.milestones)){\n            const milestone = this.milestones[key];\n            const unlockPoints = parseInt(milestone.unlockPoints);\n            // Set unlocked to true (this is saved in the save file)\n            if (this.game.highestPoints >= unlockPoints) milestone.unlocked = true;\n        }\n        // Loop over the unlocked milestones and add them to the div if they are not already in it\n        for (const key of Object.keys(this.milestones)){\n            if (this.milestones[key].unlocked) {\n                if (!this.div.contains(this.elements[key])) this.div.appendChild(this.elements[key]);\n            }\n        }\n    }\n    setup() {\n        for (const key of Object.keys(this.milestones)){\n            const milestone = this.milestones[key];\n            this.elements[key] = this.Button.createMilestoneButton(milestone);\n        }\n        this.checkMilestones();\n    }\n    update() {}\n}\n\n\nclass $ff7dba612bfe8cb2$export$568b89e600fc77eb extends (0, $b5b828a44d183c86$export$936d0764594b6eb3) {\n    constructor(game){\n        super(game, \"start\", 0, \"green\");\n        this.pointsPerClickIncrement = 1;\n        this.autoPointsEnabled = false;\n        this.pointAutoDivisor = 100;\n        this.pointsPerClick = 1;\n        this.milestoneFunctions = {\n            \"givePoints\": ()=>{\n                this.game.points += this.pointsPerClick;\n                this.game.updateUI();\n            },\n            \"increasePointsPerClick\": ()=>{\n                this.pointsPerClick += this.pointsPerClickIncrement;\n                this.game.updateUI();\n            },\n            \"autoPoints\": ()=>{\n                this.autoPointsEnabled = true;\n                this.game.updateUI();\n            }\n        };\n        this.milestones = {\n            \"givePoints\": {\n                \"text\": \"Gib Points\",\n                \"unlockPoints\": 0,\n                \"unlocked\": false,\n                \"description\": \"Give points when clicked\",\n                \"function\": this.milestoneFunctions.givePoints\n            },\n            \"increasePointsPerClick\": {\n                \"text\": \"+PPC\",\n                \"unlockPoints\": 10,\n                \"unlocked\": false,\n                \"description\": \"Increase points per click\",\n                \"function\": this.milestoneFunctions.increasePointsPerClick\n            },\n            \"autoPoints\": {\n                \"text\": \"Automates Points\",\n                \"unlockPoints\": 500,\n                \"unlocked\": false,\n                \"description\": \"Give points automatically\",\n                \"function\": this.milestoneFunctions.autoPoints\n            }\n        };\n        this.setup();\n        this.toggleVisibility();\n    }\n    update() {\n        if (this.autoPointsEnabled) this.game.points += this.pointsPerClick / this.pointAutoDivisor;\n    }\n}\n\n\n\nclass $db7dfc15e7913d22$export$8be8c2ff45d443a3 extends (0, $b5b828a44d183c86$export$936d0764594b6eb3) {\n    constructor(game){\n        super(game, \"dice\", 1000, \"white\");\n        this.layerColor = \"blue\";\n    }\n}\n\n\n\nclass $3e4e2d83e2037630$export$19600bc7e7f23c95 extends (0, $b5b828a44d183c86$export$936d0764594b6eb3) {\n    constructor(game){\n        super(game, \"coin\", 10000, \"yellow\");\n    }\n}\n\n\n// bind document.getElementById to $\nconst $e366f2c43bf887ab$var$$ = document.getElementById.bind(document);\nclass $e366f2c43bf887ab$export$985739bfa5723e08 {\n    constructor(){\n        this.fixedInterval = 3000 // Used for more process intense operations that need to be done less frequently\n        ;\n        console.log(\"Game Constructor\");\n        this.saveManager = new (0, $2be32918d126bef2$export$5bfce22a6398152d)(this);\n        this.textElements = this.getText();\n        this.navBar = $e366f2c43bf887ab$var$$(\"navBar\");\n        this.mainInterval = 1000;\n        this.points = 0;\n        this.highestPoints = 0;\n        this.layers = {\n            start: new (0, $ff7dba612bfe8cb2$export$568b89e600fc77eb)(this),\n            dice: new (0, $db7dfc15e7913d22$export$8be8c2ff45d443a3)(this),\n            coin: new (0, $3e4e2d83e2037630$export$19600bc7e7f23c95)(this)\n        };\n        this.layers.start.unlocked = true;\n        this.visibleLayer = \"start\";\n        this.tooltipsEnabled = true;\n        $e366f2c43bf887ab$var$$(\"save-button\").addEventListener(\"click\", this.save.bind(this));\n        $e366f2c43bf887ab$var$$(\"load-button\").addEventListener(\"click\", this.load.bind(this));\n        $e366f2c43bf887ab$var$$(\"tooltip-button\").addEventListener(\"click\", this.toggleTooltips.bind(this));\n        this.gameTimer = setInterval(this.update.bind(this), this.mainInterval);\n        this.fixedTimer = setInterval(this.fixedIntervalUpdate.bind(this), this.fixedInterval);\n        this.setupNav();\n    }\n    save() {\n        this.saveManager.save(this);\n    }\n    load() {\n        this.saveManager.load(this);\n    }\n    update() {\n        for (const layer of Object.keys(this.layers))this.layers[layer].update();\n        if (this.points > this.highestPoints) this.highestPoints = this.points;\n        this.updateUI();\n    }\n    fixedIntervalUpdate() {\n        for (const layer of Object.keys(this.layers))try {\n            if (!this.layers[layer].unlocked) {\n                const unlocked = this.layers[layer].tryUnlock(this.points);\n                if (unlocked) this.setupNav();\n            } else this.layers[layer].checkMilestones();\n        } catch (err) {\n            console.error(\"Error in fixedIntervalUpdate\", err);\n        }\n    }\n    toggleTooltips() {\n        this.tooltipsEnabled = !this.tooltipsEnabled;\n        this.setTooltipsState();\n    }\n    setTooltipsState() {\n        if (this.tooltipsEnabled) {\n            for (const layer of Object.keys(this.layers))for (const element of Object.keys(this.layers[layer].elements)){\n                const btn = this.layers[layer].elements[element];\n                btn.setAttribute(\"tooltipenabled\", \"enabled\");\n            }\n        } else {\n            for (const layer of Object.keys(this.layers))for (const element of Object.keys(this.layers[layer].elements)){\n                const btn = this.layers[layer].elements[element];\n                btn.setAttribute(\"tooltipenabled\", \"disabled\");\n            }\n        }\n    }\n    setupNav() {\n        this.navBar.innerHTML = \"\";\n        for (const layer of Object.keys(this.layers))if (this.layers[layer].unlocked && !this.navBar.querySelector(`#${layer}`)) {\n            const layerButton = document.createElement(\"button\");\n            layerButton.classList.add(\"hover:mb-1\", \"font-bold\");\n            layerButton.setAttribute(\"id\", layer);\n            layerButton.innerText = this.layers[layer].name.toUpperCase();\n            layerButton.addEventListener(\"click\", ()=>this.switchLayer(layer));\n            this.navBar.appendChild(layerButton);\n            console.log(\"Added button for\", layer);\n        }\n        for (const button of this.navBar.children)if (button.id === this.visibleLayer) button.classList.add(\"border-b\", `border-${this.layers[this.visibleLayer].layerColor}-500`);\n        else button.classList.remove(\"border-b\", `border-${this.layers[button.id].layerColor}-500`);\n    }\n    switchLayer(layerName) {\n        console.log(\"Switching to layer\", layerName);\n        for (const layer of Object.keys(this.layers))this.layers[layer].toggleVisibility(true);\n        this.layers[layerName].toggleVisibility();\n        for (const button of this.navBar.children)if (button.id === layerName) button.classList.add(\"border-b\", `border-${this.layers[layerName].layerColor}-500`);\n        else button.classList.remove(\"border-b\", `border-${this.layers[button.id].layerColor}-500`);\n    }\n    updateUI() {\n        this.textElements.points.innerText = this.points.toString();\n    }\n    getText() {\n        let textElements;\n        textElements = {\n            points: $e366f2c43bf887ab$var$$(\"header-text-points\"),\n            pointsPerSec: $e366f2c43bf887ab$var$$(\"header-text-points-per-sec\")\n        };\n        return textElements;\n    }\n}\nlet $e366f2c43bf887ab$var$game;\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n    $e366f2c43bf887ab$var$game = new $e366f2c43bf887ab$export$985739bfa5723e08();\n    window.game = $e366f2c43bf887ab$var$game;\n});\n\n\n//# sourceMappingURL=index.cfecd504.js.map\n","import { SaveManager } from './saving';\r\nimport { Layer } from './layers/layer';\r\nimport { Start } from './layers/start';\r\nimport { Dice } from './layers/dice';\r\nimport { Coin } from './layers/coin';\r\n\r\n// bind document.getElementById to $\r\nconst $ = document.getElementById.bind(document);\r\n\r\nexport class Game {\r\n    saveManager: SaveManager;\r\n    points: number;  // Base currency\r\n    highestPoints: number; // Highest points ever reached\r\n    textElements: { [key: string]: HTMLElement; }; // Hold text displays (may refactor soon)\r\n    mainInterval: number; // Used for the main game loop - This can be decreased over time to make the game run faster\r\n    gameTimer: number; // Holds the setInterval function for the mainInterval\r\n    fixedInterval: number = 3000;  // Used for more process intense operations that need to be done less frequently\r\n    fixedTimer: number; // Holds the setInterval function for the fixedInterval\r\n    layers: { [key: string]: Layer; };\r\n    visibleLayer: string; // Holds the name of the currently visible layer\r\n    navBar: HTMLElement;\r\n\r\n    tooltipsEnabled: boolean;\r\n\r\n\r\n    constructor() {\r\n        console.log(\"Game Constructor\")\r\n        this.saveManager = new SaveManager(this);\r\n        this.textElements = this.getText();\r\n        this.navBar = $('navBar')!;\r\n        this.mainInterval = 1000;\r\n        this.points = 0;\r\n        this.highestPoints = 0;\r\n        this.layers = { \r\n            start: new Start(this),\r\n            dice: new Dice(this),\r\n            coin: new Coin(this)\r\n        };\r\n        this.layers.start.unlocked = true;\r\n\r\n\r\n\r\n        this.visibleLayer = \"start\";\r\n        this.tooltipsEnabled = true;\r\n        $('save-button')!.addEventListener('click', this.save.bind(this));\r\n        $('load-button')!.addEventListener('click', this.load.bind(this));\r\n        $('tooltip-button')!.addEventListener('click', this.toggleTooltips.bind(this));\r\n\r\n        this.gameTimer = setInterval(this.update.bind(this), this.mainInterval);\r\n        this.fixedTimer = setInterval(this.fixedIntervalUpdate.bind(this), this.fixedInterval);\r\n        \r\n        this.setupNav();\r\n    }\r\n\r\n    save() {\r\n        this.saveManager.save(this);\r\n    }\r\n\r\n    load() {\r\n        this.saveManager.load(this);\r\n    }\r\n\r\n    update() {\r\n        for (const layer of Object.keys(this.layers)) {\r\n            this.layers[layer].update();\r\n        }\r\n        if (this.points > this.highestPoints) {\r\n            this.highestPoints = this.points;\r\n        }\r\n        this.updateUI();\r\n    }\r\n    \r\n    fixedIntervalUpdate () {\r\n        for (const layer of Object.keys(this.layers)) {\r\n            try {\r\n                if (!this.layers[layer].unlocked) {\r\n                    const unlocked = this.layers[layer].tryUnlock(this.points);\r\n                    if (unlocked) {\r\n                        this.setupNav();\r\n                    }\r\n                } else {\r\n                    this.layers[layer].checkMilestones();\r\n                }\r\n                \r\n            }\r\n            catch (err) {\r\n                console.error(\"Error in fixedIntervalUpdate\", err);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    toggleTooltips() {\r\n        this.tooltipsEnabled = !this.tooltipsEnabled;\r\n        this.setTooltipsState();\r\n    }\r\n\r\n    setTooltipsState() {\r\n        if (this.tooltipsEnabled) {\r\n            for (const layer of Object.keys(this.layers)) {\r\n                for (const element of Object.keys(this.layers[layer].elements)) {\r\n                    const btn = this.layers[layer].elements[element];\r\n                    btn.setAttribute('tooltipenabled', 'enabled');\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (const layer of Object.keys(this.layers)) {\r\n                for (const element of Object.keys(this.layers[layer].elements)) {\r\n                    const btn = this.layers[layer].elements[element];\r\n                    btn.setAttribute('tooltipenabled', 'disabled');\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    setupNav() {\r\n        this.navBar.innerHTML = '';\r\n        for (const layer of Object.keys(this.layers)) {\r\n            if (this.layers[layer].unlocked && !this.navBar.querySelector(`#${layer}`)) {\r\n                const layerButton = document.createElement('button');\r\n                layerButton.classList.add('hover:mb-1', 'font-bold');\r\n                layerButton.setAttribute('id', layer);\r\n                layerButton.innerText = this.layers[layer].name.toUpperCase();\r\n                layerButton.addEventListener('click', () => this.switchLayer(layer));\r\n                this.navBar.appendChild(layerButton);\r\n                console.log(\"Added button for\", layer)\r\n            }\r\n        }\r\n        for (const button of this.navBar.children) {\r\n            if (button.id === this.visibleLayer) {\r\n                button.classList.add('border-b', `border-${this.layers[this.visibleLayer].layerColor}-500`);\r\n            } else {\r\n                button.classList.remove('border-b', `border-${this.layers[button.id].layerColor}-500`);\r\n            }\r\n        }\r\n    }\r\n\r\n    switchLayer(layerName: string) {\r\n        console.log(\"Switching to layer\", layerName)\r\n        for (const layer of Object.keys(this.layers)) {\r\n            this.layers[layer].toggleVisibility(true);\r\n        }\r\n        this.layers[layerName].toggleVisibility();\r\n        for (const button of this.navBar.children) {\r\n            if (button.id === layerName) {\r\n                button.classList.add('border-b', `border-${this.layers[layerName].layerColor}-500`);\r\n            } else {\r\n                button.classList.remove('border-b', `border-${this.layers[button.id].layerColor}-500`);\r\n            }\r\n        }\r\n    }\r\n        \r\n    updateUI() {\r\n        this.textElements.points.innerText = this.points.toString();\r\n    }\r\n\r\n    getText(): { [key: string]: HTMLElement; } {\r\n        let textElements: { [key: string]: HTMLElement; };\r\n        textElements = {\r\n            points: $('header-text-points')!,\r\n            pointsPerSec: $('header-text-points-per-sec')!    \r\n        };\r\n        return textElements;\r\n    };\r\n}\r\n\r\nlet game: Game;\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n    game = new Game();\r\n    (window as any).game = game;\r\n});\r\n","import { Game } from \"./main\";\r\nimport localForage from 'localforage';\r\n\r\nexport class SaveManager {\r\n    game: Game;\r\n    constructor(game: Game) {\r\n        this.game = game;\r\n        console.log(\"Save Manager Constructor\")\r\n        console.log(this.game)\r\n    }\r\n\r\n    async save(game: Game) {\r\n        this.game = game;\r\n        console.log(\"Saving game\")\r\n        console.log(this.game)\r\n        const stateToSave: { [key: string]: any } = {};\r\n\r\n        stateToSave[\"points\"] = this.game.points;\r\n        stateToSave[\"visibleLayer\"] = this.game.visibleLayer;\r\n        stateToSave[\"mainInterval\"] = this.game.mainInterval;\r\n        stateToSave[\"fixedInterval\"] = this.game.fixedInterval;\r\n        stateToSave[\"highestPoints\"] = this.game.highestPoints;\r\n        stateToSave[\"tooltipsEnabled\"] = this.game.tooltipsEnabled;\r\n        \r\n        stateToSave[\"layers\"] = {\r\n            start: {\r\n                unlocked: this.game.layers.start.unlocked,\r\n                cost: this.game.layers.start.cost,\r\n                milestones: parseMilestones(this.game.layers.start.milestones),\r\n            },\r\n            dice: {\r\n                unlocked: this.game.layers.dice.unlocked,\r\n                cost: this.game.layers.dice.cost,\r\n                milestones: parseMilestones(this.game.layers.dice.milestones),\r\n            },\r\n            coin: {\r\n                unlocked: this.game.layers.coin.unlocked,\r\n                cost: this.game.layers.coin.cost,\r\n                milestones: parseMilestones(this.game.layers.coin.milestones),\r\n            }\r\n        };\r\n        \r\n        // Parse the milestones to save them, Remove the function code and reference the function by name\r\n        function parseMilestones(milestones: { [key: string]: any }): { [key: string]: any } {\r\n            const parsedMilestones: { [key: string]: {} } = {};\r\n            for (const key of Object.keys(milestones)) {\r\n                const milestone = milestones[key];\r\n                for (const milestoneKey of Object.keys(milestone)) {\r\n                    \r\n                    if (milestoneKey === 'function') {\r\n                        console.log(milestone[milestoneKey])\r\n                        milestone[milestoneKey] = milestone[milestoneKey].name;\r\n                    }\r\n                    if (milestoneKey === 'unlockPoints') {\r\n                        milestone[milestoneKey] = parseInt(milestone[milestoneKey]);\r\n                    }\r\n                }\r\n                parsedMilestones[key] = milestone;\r\n            }\r\n            return parsedMilestones;\r\n        };\r\n        \r\n        // Actually save the state\r\n        try {\r\n            console.log(\"Saving game state\", stateToSave);\r\n            await localForage.setItem(\"gameState\", stateToSave);\r\n        } catch (err) {\r\n            console.error(\"Save failed\", err);\r\n        }\r\n    }\r\n\r\n    async load(game: Game) {\r\n        this.game = game;\r\n        try {\r\n            const gameState = await localForage.getItem<any>('gameState');\r\n            console.log(\"STATE LOAD: \", gameState);\r\n\r\n            // Sets the milestones function to the actual function. This is done because the function is not saved in the save file\r\n            function parseMilestones(thisGame: any, milestones: { [key: string]: any }): { [key: string]: any } {\r\n                const parsedMilestones: { [key: string]: {} } = {};\r\n                // Loop over each actual Milestone\r\n                for (const key of Object.keys(milestones)) {\r\n                    const milestone = milestones[key];\r\n                    // Loop over each value in the milestone\r\n                    for (const milestoneKey of Object.keys(milestone)) {\r\n                        // If it is a function, set the milestone to the actual function\r\n                        if (milestoneKey === 'function') {\r\n                            milestone[milestoneKey] = thisGame.milestoneFunctions[milestone[milestoneKey]];\r\n                        }\r\n                        else milestone[milestoneKey] = milestone[milestoneKey];\r\n                        \r\n                    }\r\n                    parsedMilestones[key] = milestone;\r\n                }\r\n                return parsedMilestones;\r\n            };\r\n\r\n            if (gameState) {\r\n\r\n                this.game.points = gameState.points;\r\n                this.game.visibleLayer = gameState.visibleLayer;\r\n                this.game.mainInterval = gameState.mainInterval;\r\n                this.game.fixedInterval = gameState.fixedInterval;\r\n                this.game.highestPoints = gameState.highestPoints;\r\n                this.game.tooltipsEnabled = gameState.tooltipsEnabled;\r\n                \r\n                this.game.layers.start.unlocked = gameState.layers.start.unlocked;\r\n                this.game.layers.start.cost = gameState.layers.start.cost;\r\n                this.game.layers.start.milestones = parseMilestones(this.game.layers.start, gameState.layers.start.milestones);\r\n\r\n                this.game.layers.dice.unlocked = gameState.layers.dice.unlocked;\r\n                this.game.layers.dice.cost = gameState.layers.dice.cost;\r\n                this.game.layers.dice.milestones = parseMilestones(this.game.layers.dice, gameState.layers.dice.milestones);\r\n\r\n                this.game.layers.coin.unlocked = gameState.layers.coin.unlocked;\r\n                this.game.layers.coin.cost = gameState.layers.coin.cost;\r\n                this.game.layers.coin.milestones = parseMilestones(this.game.layers.coin, gameState.layers.coin.milestones);\r\n\r\n                this.game.setupNav();\r\n                for (const layer of Object.keys(this.game.layers)) {\r\n                    this.game.layers[layer].toggleVisibility(true);\r\n                }\r\n                this.game.switchLayer(this.game.visibleLayer);\r\n                this.game.setTooltipsState();\r\n                this.game.updateUI();\r\n                \r\n\r\n            } else {\r\n                console.log('No saved game state to load');\r\n                this.save(this.game); // Save initial state if nothing to load\r\n            }\r\n        } catch (err) {\r\n            console.error('Load failed', err);\r\n        }\r\n    }\r\n}","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb || !idb.open) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support\n        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n        // Safari 10.1 shipped with fetch, we can use that to detect it.\n        // Note: this creates issues with `window.fetch` polyfills and\n        // overrides; see:\n        // https://github.com/localForage/localForage/issues/856\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\nfunction getCallback() {\n    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n        return arguments[arguments.length - 1];\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs = void 0;\nvar dbContexts = {};\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve, reject) {\n        deferredOperation.resolve = resolve;\n        deferredOperation.reject = reject;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n        return deferredOperation.promise;\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n        return deferredOperation.promise;\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            var db = openreq.result;\n            db.onversionchange = function (e) {\n                // Triggered when the database is modified (e.g. adding an objectStore) or\n                // deleted (even when initiated by other sessions in different tabs).\n                // Closing the connection here prevents those operations from being blocked.\n                // If the database is accessed again later by this instance, the connection\n                // will be reopened or the database recreated as needed.\n                e.target.close();\n            };\n            resolve(db);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        var forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    dbInfo.db = null;\n\n    return _getOriginalConnection(dbInfo).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        // store the latest db reference\n        // in case the db was upgraded\n        dbInfo.db = dbContext.db = db;\n        for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback, retries) {\n    if (retries === undefined) {\n        retries = 1;\n    }\n\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n            return Promise$1.resolve().then(function () {\n                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                    // increase the db version, to create the new ObjectStore\n                    if (dbInfo.db) {\n                        dbInfo.version = dbInfo.db.version + 1;\n                    }\n                    // Reopen the database for upgrading.\n                    return _getUpgradedConnection(dbInfo);\n                }\n            }).then(function () {\n                return _tryReconnect(dbInfo).then(function () {\n                    createTransaction(dbInfo, mode, callback, retries - 1);\n                });\n            })[\"catch\"](callback);\n        }\n\n        callback(err);\n    }\n}\n\nfunction createDbContext() {\n    return {\n        // Running localForages sharing a database.\n        forages: [],\n        // Shared database.\n        db: null,\n        // Database readiness (promise).\n        dbReady: null,\n        // Deferred operations on the database.\n        deferredOperations: []\n    };\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = createDbContext();\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback returns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openKeyCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openKeyCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n\n        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n            var dbContext = dbContexts[options.name];\n            var forages = dbContext.forages;\n            dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n            return db;\n        });\n\n        if (!options.storeName) {\n            promise = dbPromise.then(function (db) {\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                }\n\n                var dropDBPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.deleteDatabase(options.name);\n\n                    req.onerror = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        reject(req.error);\n                    };\n\n                    req.onblocked = function () {\n                        // Closing all open connections in onversionchange handler should prevent this situation, but if\n                        // we do get here, it just means the request remains pending - eventually it will succeed or error\n                        console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        resolve(db);\n                    };\n                });\n\n                return dropDBPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var i = 0; i < forages.length; i++) {\n                        var _forage = forages[i];\n                        _advanceReadiness(_forage._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        } else {\n            promise = dbPromise.then(function (db) {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                    return;\n                }\n\n                var newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                    forage._dbInfo.version = newVersion;\n                }\n\n                var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.open(options.name, newVersion);\n\n                    req.onerror = function (err) {\n                        var db = req.result;\n                        db.close();\n                        reject(err);\n                    };\n\n                    req.onupgradeneeded = function () {\n                        var db = req.result;\n                        db.deleteObjectStore(options.storeName);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        db.close();\n                        resolve(db);\n                    };\n                });\n\n                return dropObjectPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var j = 0; j < forages.length; j++) {\n                        var _forage2 = forages[j];\n                        _forage2._dbInfo.db = db;\n                        _advanceReadiness(_forage2._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        }\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nfunction createDbTable(t, dbInfo, callback, errorCallback) {\n    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n}\n\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            createDbTable(t, dbInfo, function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        }, reject);\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n    t.executeSql(sqlStatement, args, callback, function (t, error) {\n        if (error.code === error.SYNTAX_ERR) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                if (!results.rows.length) {\n                    // if the table is missing (was deleted)\n                    // re-create it table and retry\n                    createDbTable(t, dbInfo, function () {\n                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                    }, errorCallback);\n                } else {\n                    errorCallback(t, error);\n                }\n            }, errorCallback);\n        } else {\n            errorCallback(t, error);\n        }\n    }, errorCallback);\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// https://www.w3.org/TR/webdatabase/#databases\n// > There is no way to enumerate or delete the databases available for an origin from this API.\nfunction getAllStoreNames(db) {\n    return new Promise$1(function (resolve, reject) {\n        db.transaction(function (t) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                var storeNames = [];\n\n                for (var i = 0; i < results.rows.length; i++) {\n                    storeNames.push(results.rows.item(i).name);\n                }\n\n                resolve({\n                    db: db,\n                    storeNames: storeNames\n                });\n            }, function (t, error) {\n                reject(error);\n            });\n        }, function (sqlError) {\n            reject(sqlError);\n        });\n    });\n}\n\nfunction dropInstance$1(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n            } else {\n                db = openDatabase(options.name, '', '', 0);\n            }\n\n            if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n            } else {\n                resolve({\n                    db: db,\n                    storeNames: [options.storeName]\n                });\n            }\n        }).then(function (operationInfo) {\n            return new Promise$1(function (resolve, reject) {\n                operationInfo.db.transaction(function (t) {\n                    function dropTable(storeName) {\n                        return new Promise$1(function (resolve, reject) {\n                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                                resolve();\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        });\n                    }\n\n                    var operations = [];\n                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                        operations.push(dropTable(operationInfo.storeNames[i]));\n                    }\n\n                    Promise$1.all(operations).then(function () {\n                        resolve();\n                    })[\"catch\"](function (e) {\n                        reject(e);\n                    });\n                }, function (sqlError) {\n                    reject(sqlError);\n                });\n            });\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1,\n    dropInstance: dropInstance$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\n        // in IE8 typeof localStorage.setItem === 'object'\n        !!localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction _getKeyPrefix(options, defaultConfig) {\n    var keyPrefix = options.name + '/';\n\n    if (options.storeName !== defaultConfig.storeName) {\n        keyPrefix += options.storeName + '/';\n    }\n    return keyPrefix;\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance$2(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        var currentConfig = this.config();\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            if (!options.storeName) {\n                resolve(options.name + '/');\n            } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n        }).then(function (keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2,\n    dropInstance: dropInstance$2\n};\n\nvar sameValue = function sameValue(x, y) {\n    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n};\n\nvar includes = function includes(array, searchElement) {\n    var len = array.length;\n    var i = 0;\n    while (i < len) {\n        if (sameValue(array[i], searchElement)) {\n            return true;\n        }\n        i++;\n    }\n\n    return false;\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar OptionalDriverMethods = ['dropInstance'];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var driverMethodName = driverMethods[i];\n\n                    // when the property is there,\n                    // it should be a method even when optional\n                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var configureMissingMethods = function configureMissingMethods() {\n                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                        return function () {\n                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                            var promise = Promise$1.reject(error);\n                            executeCallback(promise, arguments[arguments.length - 1]);\n                            return promise;\n                        };\n                    };\n\n                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                        if (!driverObject[optionalDriverMethod]) {\n                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                        }\n                    }\n                };\n\n                configureMissingMethods();\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n","import { Layer } from \"./layer\";\r\nimport { Game } from \"../main\";\r\n\r\n\r\nexport class Start extends Layer {\r\n    pointsPerClickIncrement: number;\r\n    pointsPerClick: number;\r\n    pointAutoDivisor: number;\r\n    autoPointsEnabled: boolean;\r\n    constructor(game: Game) {\r\n        super(game, \"start\", 0, \"green\");\r\n        this.pointsPerClickIncrement = 1;\r\n        this.autoPointsEnabled = false;\r\n        this.pointAutoDivisor = 100;\r\n        this.pointsPerClick = 1;\r\n\r\n        this.milestoneFunctions = {\r\n            \"givePoints\": () => {\r\n                this.game.points += this.pointsPerClick;\r\n                this.game.updateUI();\r\n            },\r\n            \"increasePointsPerClick\": () => {\r\n                this.pointsPerClick += this.pointsPerClickIncrement;\r\n                this.game.updateUI();\r\n            },\r\n            \"autoPoints\": () => {\r\n                this.autoPointsEnabled = true;\r\n                this.game.updateUI();\r\n            }\r\n        }\r\n\r\n        this.milestones = { \r\n            \"givePoints\": {\r\n                \"text\": \"Gib Points\",\r\n                \"unlockPoints\": 0,\r\n                \"unlocked\": false,\r\n                \"description\": \"Give points when clicked\",\r\n                \"function\": this.milestoneFunctions.givePoints,\r\n            },\r\n            \"increasePointsPerClick\": {\r\n                \"text\": \"+PPC\",\r\n                \"unlockPoints\": 10,\r\n                \"unlocked\": false,\r\n                \"description\": \"Increase points per click\",\r\n                \"function\": this.milestoneFunctions.increasePointsPerClick,\r\n            },\r\n            \"autoPoints\": {\r\n                \"text\": \"Automates Points\",\r\n                \"unlockPoints\": 500,\r\n                \"unlocked\": false,\r\n                \"description\": \"Give points automatically\",\r\n                \"function\": this.milestoneFunctions.autoPoints,\r\n            }\r\n        };\r\n\r\n\r\n        this.setup();\r\n        this.toggleVisibility();\r\n    }\r\n    update() {\r\n        if (this.autoPointsEnabled) {\r\n            this.game.points += this.pointsPerClick / this.pointAutoDivisor;\r\n        }\r\n    }\r\n}","import { Game } from \"../main\";\r\nimport { Button } from \"../utils\";\r\n\r\n// bind document.getElementById to $\r\nconst $ = document.getElementById.bind(document);\r\n\r\n\r\nexport class Layer {\r\n    game: Game;\r\n    Button: typeof Button;\r\n    name: string;\r\n    unlocked: boolean = false;\r\n    cost: number;\r\n    layerColor: string;\r\n    milestones: { [key: string]: {[key: string]: any}; };\r\n    // milestonesUnlocked: { [key: string]: boolean; };\r\n    milestoneFunctions: { [key: string]: () => any; };\r\n\r\n    parentElement: HTMLElement = $('main')!;\r\n    div: HTMLElement;\r\n    visible: boolean = false;\r\n    elements: { [key: string]: HTMLElement; };\r\n    layerTitle: HTMLElement;\r\n\r\n    constructor(game: Game,name: string, cost: number, layerColor: string) {\r\n        this.Button = Button;\r\n        this.game = game;\r\n        this.name = name;\r\n        this.cost = cost;\r\n        this.layerColor = layerColor;\r\n\r\n        this.milestones = {\r\n            // \"test\": {\r\n            //     \"text\": \"Test Milestone\",\r\n            //     \"unlockPoints\": 0,\r\n            //     \"unlocked\": false,\r\n            //     \"description\": \"Test Milestone\",\r\n            //     \"function\": this.milestoneFunctions.test,\r\n            // }\r\n        };\r\n        // this.milestonesUnlocked = {};\r\n        this.milestoneFunctions = {\r\n            \"test\": () => {\r\n                console.log(\"Test Milestone\");\r\n                console.log(\"End Test Milestone\");\r\n            }\r\n        };\r\n\r\n        // create a blank div that fills the entire parent, and add it to the parent which is main\r\n        this.div = document.createElement('div');\r\n        this.parentElement.appendChild(this.div);\r\n        this.div.classList.add('flex', 'flex-col', 'w-full', 'h-full', 'hidden');\r\n        this.div.setAttribute('id', this.name);\r\n\r\n        // create a title for the layer\r\n        this.layerTitle = document.createElement('div');\r\n        this.div.appendChild(this.layerTitle);\r\n        this.layerTitle.innerText = this.name.toUpperCase();\r\n        this.layerTitle.classList.add('text-2xl', 'text-center', 'mb-4', 'font-bold', 'w-full', 'border-b-2', `border-${this.layerColor}-500`);\r\n       \r\n        this.elements = {};\r\n    }\r\n\r\n    tryUnlock(currentPoints: number): boolean {\r\n        // console.log(\"Trying to unlock\", this.name, \"with\", currentPoints, \"/\", this.cost, \"points\");\r\n        if (currentPoints >= this.cost) {\r\n            this.unlocked = true;\r\n            console.log(\"Unlocked Layer\", this.name);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    toggleVisibility(forceHide?: boolean) {\r\n        if (forceHide) {\r\n            if (this.div.classList.contains('hidden')) {\r\n                this.visible = false;\r\n                return;\r\n            }\r\n            else {\r\n                this.div.classList.add('hidden');\r\n                this.visible = false;\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            if (this.visible) {\r\n                this.div.classList.add('hidden');\r\n                this.visible = false;\r\n            } else {\r\n                this.div.classList.remove('hidden');\r\n                this.visible = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    checkMilestones() {\r\n        for (const key of Object.keys(this.milestones)) {\r\n            const milestone = this.milestones[key];\r\n            const unlockPoints = parseInt(milestone.unlockPoints);\r\n            // Set unlocked to true (this is saved in the save file)\r\n            if (this.game.highestPoints >= unlockPoints) {\r\n                milestone.unlocked = true;\r\n            }\r\n        }\r\n        // Loop over the unlocked milestones and add them to the div if they are not already in it\r\n        for (const key of Object.keys(this.milestones)) {\r\n            if (this.milestones[key].unlocked) {\r\n                if (!this.div.contains(this.elements[key])) {\r\n                    this.div.appendChild(this.elements[key]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    setup() {\r\n        for (const key of Object.keys(this.milestones)) {\r\n            const milestone = this.milestones[key];\r\n            this.elements[key] = this.Button.createMilestoneButton(milestone);\r\n        }\r\n        this.checkMilestones();\r\n    }\r\n\r\n    update() {\r\n        \r\n    }\r\n}","\r\nexport class Button {\r\n    private buttonCSS: string = 'bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded w-1/4 mx-auto mt-4';\r\n    name: string;\r\n    txt: string;\r\n    description: string;\r\n    callback: () => void;\r\n    button: HTMLElement;\r\n\r\n    constructor(name: string, txt: string, callback: () => void, css: string = '') {\r\n        this.buttonCSS = css ? css : this.buttonCSS;\r\n        this.name = name;\r\n        this.txt = txt;\r\n        this.description = '';\r\n        this.callback = callback;\r\n        this.button = document.createElement('button');\r\n        this.init();\r\n    }\r\n\r\n    private init(): HTMLElement {\r\n        this.button.textContent = this.txt;\r\n        this.button.className = this.buttonCSS;\r\n        this.button.addEventListener('click', this.callback);\r\n        this.button.setAttribute('tooltipenabled', 'enabled');        \r\n        \r\n        \r\n        // Tooltip\r\n        this.button.addEventListener('mouseover', (event) => {\r\n            if (this.button.getAttribute('tooltipenabled') !== 'enabled') return;\r\n            const descriptionDiv = document.createElement('div');\r\n            descriptionDiv.textContent = this.description;\r\n            descriptionDiv.className = 'absolute bg-gray-900 p-2 rounded z-10 font-bold'; // z-10 to ensure it's above other items\r\n            document.body.appendChild(descriptionDiv); // Append to body to ensure it's not constrained by button's position\r\n    \r\n            const updateTooltipPosition = (mouseEvent: MouseEvent) => {\r\n                descriptionDiv.style.left = `${mouseEvent.clientX + 10}px`; // +10 for a slight offset from the cursor\r\n                descriptionDiv.style.top = `${mouseEvent.clientY + 10}px`;\r\n            };\r\n    \r\n            // Initial position update\r\n            updateTooltipPosition(event);\r\n            \r\n            // Update tooltip position on mouse move\r\n            this.button.addEventListener('mousemove', updateTooltipPosition);\r\n    \r\n            // Clean up: remove tooltip and event listener when mouse leaves\r\n            this.button.addEventListener('mouseleave', () => {\r\n                descriptionDiv.remove();\r\n                this.button.removeEventListener('mousemove', updateTooltipPosition);\r\n            }, { once: true }); // Use { once: true } to automatically remove this event listener after it triggers once\r\n        });\r\n    \r\n        return this.button;\r\n    }\r\n    \r\n\r\n    // Optionally, create a static factory method to directly return the button element\r\n    static createButton(name: string, txt: string, callback: () => void, css: string = ''): HTMLElement {\r\n        const btn = new Button(name, txt, callback, css);\r\n        return btn.button;\r\n    }\r\n    // Optionally, create a static factory method to directly return the button element\r\n    static createMilestoneButton(milestone: {[key: string]: any}, css: string = ''): HTMLElement {\r\n        const btn = new Button(milestone.name, milestone.text, milestone.function, css);\r\n        btn.description = milestone.description;\r\n        return btn.button;\r\n    }\r\n\r\n}","import { Layer } from \"./layer\";\r\nimport { Game } from \"../main\";\r\n\r\nexport class Dice extends Layer { \r\n    constructor(game: Game) {\r\n        super(game, \"dice\", 1000, \"white\");\r\n        this.layerColor = \"blue\";\r\n\r\n    }\r\n    \r\n}\r\n","import { Layer } from \"./layer\";\r\nimport { Game } from \"../main\";\r\n\r\nexport class Coin extends Layer {\r\n    constructor(game: Game) {\r\n        super(game, \"coin\", 10000, \"yellow\");\r\n        \r\n    }\r\n    \r\n}"],"names":["$e366f2c43bf887ab$var$game","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","$26ce26772c045640$exports","e","t","n","r","s","o","u","undefined","i","f","Error","code","l","exports","call","length","_dereq_","module1","global1","scheduleDrain","draining","Mutation","MutationObserver","WebKitMutationObserver","called","observer","nextTick","element","document","createTextNode","observe","characterData","data","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","channel","port1","onmessage","port2","postMessage","queue","oldQueue","len","task","push","self","window","immediate","INTERNAL","handlers","REJECTED","FULFILLED","PENDING","Promise1","resolver","TypeError","state","outcome","safelyResolveThenable","QueueItem","promise","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","value","returnValue","reject","resolve","getThen","obj","then","apply","arguments","self1","thenable","onError","onSuccess","result","tryCatch","status","out","prototype","constructor","error","reason","all","iterable","Object","toString","values","Array","resolved","allResolver","outValue","race","response","Promise","_typeof","Symbol","iterator","idb","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","createBlob","parts","properties","Blob","name","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","append","getBlob","type","Promise$1","executeCallback","callback","executeTwoCallbacks","errorCallback","normalizeKey","key","console","warn","String","getCallback","DETECT_BLOB_SUPPORT_STORE","supportsBlobs","dbContexts","READ_ONLY","READ_WRITE","_deferReadiness","dbInfo","dbContext","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_rejectReadiness","err","_getConnection","upgradeNeeded","createDbContext","db","close","dbArgs","version","openreq","open","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","newVersion","onerror","preventDefault","onsuccess","onversionchange","target","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_decodeBlob","encodedBlob","_binStringToArrayBuffer","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","atob","_isEncodedBlob","__local_forage_encoded_blob","_fullyReady","_initReady","_dbInfo","createTransaction","mode","retries","tx","transaction","_tryReconnect","forages","forage","_getOriginalConnection","asyncStorage","_driver","_initStorage","options","ready","initPromises","ignoreErrors","j","slice","_defaultConfig","k","_support","isIndexedDBValid","isSafari","openDatabase","test","navigator","userAgent","platform","hasFetch","fetch","indexOf","IDBKeyRange","iterate","req","store","objectStore","openCursor","iterationNumber","cursor","getItem","get","setItem","_checkBlobSupport","_checkBlobSupportWithoutCaching","txn","blob","put","onabort","stopPropagation","oncomplete","matchedChrome","match","matchedEdge","parseInt","blobSupport","reader","FileReader","onloadend","btoa","readAsBinaryString","removeItem","clear","count","advanced","openKeyCursor","advance","keys","dropInstance","currentConfig","config","dbPromise","isCurrentDb","dropObjectPromise","deleteObjectStore","_forage2","dropDBPromise","deleteDatabase","onblocked","_forage","BASE_CHARS","BLOB_TYPE_PREFIX_REGEX","SERIALIZED_MARKER","SERIALIZED_MARKER_LENGTH","TYPE_ARRAYBUFFER","TYPE_BLOB","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT16ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","TYPE_SERIALIZED_MARKER_LENGTH","toString$1","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","p","buffer","bytes","bufferToString","base64String","substring","localforageSerializer","serialize","valueType","marker","fileReader","onload","BLOB_TYPE_PREFIX","readAsArrayBuffer","JSON","stringify","deserialize","parse","blobType","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","createDbTable","executeSql","tryExecuteSql","sqlStatement","args","SYNTAX_ERR","results","rows","_setItem","retriesLeft","originalValue","serializer","sqlError","QUOTA_ERR","webSQLStorage","dbInfoPromise","description","size","item","c","storeNames","operationInfo","operations","dropTable","_getKeyPrefix","defaultConfig","keyPrefix","localStorageWrapper","checkIfLocalStorageThrows","localStorageTestKey","localStorage","isLocalStorageValid","keyPrefixLength","itemKey","includes","array","searchElement","x","isNaN","isArray","arg","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","DefaultDriverOrder","OptionalDriverMethods","LibraryMethods","concat","DefaultConfig","driver","extend","_key","hasOwnProperty","localforage_js","LocalForage","driverTypeKey","_classCallCheck","instance","Constructor","driverName","defineDriver","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","replace","driverObject","complianceError","driverMethods","driverMethodName","isRequired","configureMissingMethods","methodNotImplementedFactory","methodName","_i","_len","optionalDriverMethod","setDriverSupport","support","info","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","supportedDrivers","_getSupportedDrivers","setDriverToConfig","extendSelfWithDriver","_extend","oldDriverSetDone","currentDriverIndex","driverPromiseLoop","supports","libraryMethodsAndProperties","callWhenReady","localForageInstance","libraryMethod","_args","createInstance","$2be32918d126bef2$export$5bfce22a6398152d","game","log","save","stateToSave","parseMilestones","milestones","parsedMilestones","milestone","milestoneKey","points","visibleLayer","mainInterval","fixedInterval","highestPoints","tooltipsEnabled","start","unlocked","layers","cost","dice","coin","load","gameState","thisGame","milestoneFunctions","layer","setupNav","toggleVisibility","switchLayer","setTooltipsState","updateUI","$2e57933e65d9ec74$export$353f5b6fc5456de1","txt","css","buttonCSS","button","init","textContent","className","addEventListener","setAttribute","event","getAttribute","descriptionDiv","body","updateTooltipPosition","mouseEvent","style","left","clientX","top","clientY","remove","removeEventListener","once","createButton","btn","createMilestoneButton","text","function","$b5b828a44d183c86$var$$","getElementById","bind","$b5b828a44d183c86$export$936d0764594b6eb3","layerColor","parentElement","visible","Button","div","classList","add","layerTitle","innerText","toUpperCase","elements","tryUnlock","currentPoints","forceHide","checkMilestones","unlockPoints","setup","update","$ff7dba612bfe8cb2$export$568b89e600fc77eb","pointsPerClickIncrement","autoPointsEnabled","pointAutoDivisor","pointsPerClick","givePoints","increasePointsPerClick","autoPoints","$db7dfc15e7913d22$export$8be8c2ff45d443a3","$3e4e2d83e2037630$export$19600bc7e7f23c95","$e366f2c43bf887ab$var$$","$e366f2c43bf887ab$export$985739bfa5723e08","saveManager","textElements","getText","navBar","toggleTooltips","gameTimer","setInterval","fixedTimer","fixedIntervalUpdate","innerHTML","querySelector","layerButton","children","id","layerName","pointsPerSec"],"version":3,"file":"index.cfecd504.js.map"}